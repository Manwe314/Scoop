#version 460
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 8, local_size_y = 8) in;

// ---------- Params (set 1, binding 3) ----------
layout(set = 1, binding = 3, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;
    uint  flags;
} Params;

// ---------- Dynamic wavefront buffers (set 2) ----------

struct PathHeader {
    uint pixelIndex;
    uint rngState;
    uint depth;
    uint flags;
};

struct RayData {
    vec4 origin;
    vec4 direction;
};

struct HitIds {
    uint instanceIndex;
    uint primitiveIndex;
};

struct Hitdata {
    float worldT;
    float localT;
    float baryU;
    float baryV;
};

struct RadianceState {
    vec4  throughput;
    vec4  radiance;
    float prevBsdfPdf;
    float pad0;
    float pad1;
    float pad2;
};

struct BsdfSample {
    vec4 dir;
    vec4 f;
    float pdf;
    float cosTheta;
    float pdf_L_B;
    float pad0;
};

struct LightSample {
    vec4 dir;
    vec4 Li_fL;
    float pdf;
    float cosTheta;
    float pdf_B_L;
    uint  lightId;
    uint  pad0;
};

struct ShadowRay {
    vec4 origin;
    vec4 direction;
    uint lightId;
    uint primitiveId;
    uint pad0;
    uint pad1;
};

struct ShadowResult {
    uint visible;
    uint pad0;
    uint pad1;
    uint pad2;
};

struct PathQueue {
    uint count;
    uint pad0;
    uint pad1;
    uint pad2;
};

struct PixelStats {
    vec4 mean;
    vec4 m2;
    uint sampleCount;
    uint flags;
};

layout(set = 2, binding = 0, std430)  buffer PathHeaderBuf   { PathHeader     pathHeaders[];   };
layout(set = 2, binding = 1, std430)  buffer RayBuf          { RayData        rays[];          };
layout(set = 2, binding = 2, std430)  buffer HitIdsBuf       { HitIds         hitIds[];        };
layout(set = 2, binding = 3, std430)  buffer HitdataBuf      { Hitdata        hitData[];       };
layout(set = 2, binding = 4, std430)  buffer RadianceBuf     { RadianceState  radianceStates[];};
layout(set = 2, binding = 5, std430)  buffer BsdfSampleBuf   { BsdfSample     bsdfSamples[];   };
layout(set = 2, binding = 6, std430)  buffer LightSampleBuf  { LightSample    lightSamples[];  };
layout(set = 2, binding = 7, std430)  buffer ShadowRayBuf    { ShadowRay      shadowRays[];    };
layout(set = 2, binding = 8, std430)  buffer ShadowResBuf    { ShadowResult   shadowResults[]; };
layout(set = 2, binding = 9, std430)  buffer PathQueueBuf    { PathQueue      pathQueues[];    };
layout(set = 2, binding = 10, std430) buffer PixelStatsBuf   { PixelStats     pixelStats[];    };
layout(set = 2, binding = 11, std430) buffer HighVarPixelBuf { uint     highVarPixelIndices[]; };
layout(set = 2, binding = 12, std430) buffer AdaptiveCounters{
    uint highVarCount;
    uint rescheduleCounter;
};

const uint PATH_STATE_INIT        = 0u;
const uint PATH_STATE_NEED_HIT    = 1u;
const uint PATH_STATE_NEED_SHADE  = 2u;
const uint PATH_STATE_NEED_SHADOW = 3u;
const uint PATH_STATE_NEED_MIS    = 4u;
const uint PATH_STATE_DEAD_WRITTEN= 5u;
const uint PATH_STATE_COMPLETE    = 6u;
const uint PATH_STATE_DEAD        = 7u;
const uint PATH_STATE_NEED_RAY    = 8u;
const uint DEPTH_BITS = 16u;
const uint DEPTH_MASK = 0x0000FFFFu;
const uint SPP_MASK   = 0xFFFF0000u;
    


// ---------- RNG helpers ----------

uint getDepth(uint packed)
{
    return packed & DEPTH_MASK;
}

uint getSPP(uint packed)
{
    return packed >> DEPTH_BITS;
}

void setDepth(inout uint packed, uint depth)
{
    packed = (packed & SPP_MASK) | (depth & DEPTH_MASK);
}

void setSPP(inout uint packed, uint spp)
{
    packed = (packed & DEPTH_MASK) | ((spp & DEPTH_MASK) << DEPTH_BITS);
}

uint wang_hash(uint s)
{
    s = (s ^ 61u) ^ (s >> 16);
    s *= 9u;
    s = s ^ (s >> 4);
    s *= 0x27d4eb2du;
    s = s ^ (s >> 15);
    return s;
}

uint xorshift(inout uint state)
{
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    return state;
}

float floatConstruct(uint state)
{
    const uint ieeeMantissa = 0x007FFFFFu;
    const uint ieeeOne      = 0x3F800000u;

    state &= ieeeMantissa;
    state |= ieeeOne;

    float  f = uintBitsToFloat(state);
    return f - 1.0;
}

float rand(inout uint state)
{
    return floatConstruct(wang_hash(xorshift(state)));
}

// ---------- camera ray generation ----------

struct Ray {
    vec3 origin;
    vec3 direction;
};

Ray generateRayJittered(uvec2 pixel, vec2 jitter)
{
    vec2 pixelSample = vec2(pixel) + jitter;

    vec2 UV = pixelSample / vec2(Params.imageSize);
    vec2 ndc = UV * 2.0 - 1.0;

    vec4 nearPoint = Params.viewProjInv * vec4(ndc, 0.0, 1.0);
    vec4 farPoint  = Params.viewProjInv * vec4(ndc, 1.0, 1.0);

    vec3 p0 = nearPoint.xyz / nearPoint.w;
    vec3 p1 = farPoint.xyz  / farPoint.w;

    Ray ray;
    ray.origin    = Params.camPos_time.xyz;
    ray.direction = normalize(p1 - p0);
    return ray;
}

uvec2 unpackPixelCoords(uint pixelIndex)
{
    uint x = pixelIndex % Params.imageSize.x;
    uint y = pixelIndex / Params.imageSize.x;
    return uvec2(x, y);
}

void main()
{
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= Params.imageSize.x || gid.y >= Params.imageSize.y)
        return;

    uint pathId = gid.x + gid.y * Params.imageSize.x;

    PathHeader header = pathHeaders[pathId];

    if (header.flags == PATH_STATE_INIT)
    {
        header.pixelIndex = pathId;

        PixelStats ps;
        ps.mean        = vec4(0.0);
        ps.m2          = vec4(0.0);
        ps.sampleCount = 0u;
        ps.flags       = 0u;
        pixelStats[pathId] = ps;

        if (pathId == 0)
        {
            highVarCount      = 0u;
            rescheduleCounter = 0u;
        }

        header.flags = PATH_STATE_NEED_RAY;
        pathHeaders[pathId] = header;
    }

    if (header.flags != PATH_STATE_NEED_RAY)
        return;

    uint spp = getSPP(header.depth);
    setDepth(header.depth, 0u);

    uvec2 pixel = unpackPixelCoords(header.pixelIndex);
    if (pixel.x >= Params.imageSize.x || pixel.y >= Params.imageSize.y)
        return;

    uint frameIndex = floatBitsToUint(Params.camPos_time.w);
    uint seed = ((pathId + 320452039u) * frameIndex) ^ header.pixelIndex ^ ((spp + 1239741293u) * 1664525u);
    uint rngState = wang_hash(seed);

    vec2 jitter = vec2(rand(rngState), rand(rngState));
    Ray ray = generateRayJittered(pixel, jitter);

    rays[pathId].origin    = vec4(ray.origin,    0.0);
    rays[pathId].direction = vec4(ray.direction, 0.0);

    header.rngState = rngState;
    header.flags    = PATH_STATE_NEED_HIT;
    pathHeaders[pathId] = header;

    RadianceState radiance;
    radiance.throughput   = vec4(1.0, 1.0, 1.0, 0.0);
    radiance.radiance     = vec4(0.0);
    radiance.prevBsdfPdf  = 0.0;
    radiance.pad0         = 0.0;
    radiance.pad1         = 0.0;
    radiance.pad2         = 0.0;
    radianceStates[pathId] = radiance;

    hitIds[pathId].instanceIndex  = 0xFFFFFFFFu;
    hitIds[pathId].primitiveIndex = 0xFFFFFFFFu;
    hitData[pathId]               = Hitdata(0.0, 0.0, 0.0, 0.0);

    bsdfSamples[pathId].pdf      = 0.0;
    bsdfSamples[pathId].cosTheta = 0.0;
    bsdfSamples[pathId].pdf_L_B  = 0.0;

    lightSamples[pathId].pdf      = 0.0;
    lightSamples[pathId].cosTheta = 0.0;
    lightSamples[pathId].pdf_B_L  = 0.0;

    shadowResults[pathId].visible = 0u;
}
