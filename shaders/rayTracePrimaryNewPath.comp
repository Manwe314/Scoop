#version 460
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 8, local_size_y = 8) in;

// ---------- Params (set 1, binding 3) ----------
layout(set = 1, binding = 3, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;
    uint  flags;
} Params;

// ---------- Dynamic wavefront buffers (set 2) ----------

struct RayData {
    vec4 origin;
    vec4 direction;
};

layout(set = 2, binding = 13, std430) buffer PrimaryRayBuf     { RayData   primaryRays[];     };

// ---------- camera ray generation ----------

struct Ray {
    vec3 origin;
    vec3 direction;
};


Ray generateRay(const in uvec2 pixel)
{
    vec2 UV = (vec2(pixel) + 0.5) / vec2(Params.imageSize);

    vec2 normalisedDeviceCoordinate = UV * 2.0 - 1.0;

    vec4 nearPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 0.0, 1.0);
    vec4 farPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 1.0, 1.0);

    vec3 point0 = nearPoint.xyz / nearPoint.w;
    vec3 point1 = farPoint.xyz / farPoint.w;

    Ray ray;
    ray.origin = Params.camPos_time.xyz;
    ray.direction = normalize(point1 - point0);
    return ray;
}

uvec2 unpackPixelCoords(uint pixelIndex)
{
    uint x = pixelIndex % Params.imageSize.x;
    uint y = pixelIndex / Params.imageSize.x;
    return uvec2(x, y);
}

void main()
{
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= Params.imageSize.x || gid.y >= Params.imageSize.y)
        return;

    uint pathId = gid.x + gid.y * Params.imageSize.x;

    Ray ray = generateRay(gid);

    primaryRays[pathId].origin    = vec4(ray.origin,    0.0);
    primaryRays[pathId].direction = vec4(ray.direction, 0.0);
}
