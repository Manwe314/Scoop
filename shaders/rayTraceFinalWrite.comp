#version 460
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 1, binding = 4, rgba16f) uniform image2D outImage;
layout(set = 1, binding = 14) uniform sampler2D nrdOutDiff;
layout(set = 1, binding = 15) uniform sampler2D nrdOutSpec;


layout(set = 1, binding = 9,  rgba16f) uniform readonly image2D inDiff;
layout(set = 1, binding = 10, rgba16f) uniform readonly image2D inSpec;
layout(set = 1, binding = 11, rgba16_snorm) uniform readonly image2D inNormalRoughness;
layout(set = 1, binding = 12, r32f)         uniform readonly image2D inViewZ;
layout(set = 1, binding = 13, rgba16f)   uniform readonly image2D inMotion;

layout(set = 1, binding = 3, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;
    uint  flags;
    vec2  cameraJitter;
    vec2  cameraJitterPrev;
} Params;

const uint FLAG_DEBUG_NRD_INPUTS = 1u << 19;

vec3 visualizeViewZ(float z)
{
    // Log-ish scale to bring large depths into [0,1].
    float v = log2(max(z, 1e-4) + 1.0) * 0.05;
    return vec3(clamp(v, 0.0, 1.0));
}

vec3 visualizeMotion(vec2 mv)
{
    float mag = length(mv);
    return vec3(mv * 0.5 + 0.5, clamp(mag * 0.1, 0.0, 1.0));
}

vec3 fetchInput(uint idx, ivec2 samplePx)
{
    if (idx == 1u) return imageLoad(inDiff, samplePx).xyz;
    if (idx == 0u) return imageLoad(inSpec, samplePx).xyz;
    if (idx == 2u)
    {
        vec4 nr = imageLoad(inNormalRoughness, samplePx);
        vec3 n  = normalize(nr.xyz);
        return n * 0.5 + 0.5;
    }
    if (idx == 3u)
    {
        float z = imageLoad(inViewZ, samplePx).x;
        return visualizeViewZ(z);
    }
    if (idx == 4u)
    {
        vec2 mv = imageLoad(inMotion, samplePx).xy;
        return visualizeMotion(mv);
    }
    return vec3(0.0);
}

void main()
{
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= Params.imageSize.x || gid.y >= Params.imageSize.y)
        return;

    ivec2 pixel = ivec2(gid);
    bool debugInputs = (Params.flags & FLAG_DEBUG_NRD_INPUTS) != 0u;

    vec3 color;
    if (!debugInputs)
    {
        vec3 diff = texelFetch(nrdOutDiff, pixel, 0).xyz;
        vec3 spec = texelFetch(nrdOutSpec, pixel, 0).xyz;
        color = diff + spec;
    }
    else
    {
        // 3x2 grid covering the output; first 5 cells show NRD inputs.
        const uvec2 grid = uvec2(3, 2);
        uvec2 tileSize = (Params.imageSize + grid - 1u) / grid;
        uvec2 tile     = gid / tileSize;

        uint tileIndex = tile.x + tile.y * grid.x;
        if (tile.x >= grid.x || tile.y >= grid.y || tileIndex >= 5u)
        {
            color = vec3(0.0);
        }
        else
        {
            uvec2 local = gid - tile * tileSize;
            vec2 uv     = (vec2(local) + 0.5) / vec2(tileSize);
            vec2 samplePos = uv * (vec2(Params.imageSize) - 1.0);
            ivec2 samplePx = ivec2(clamp(samplePos, vec2(0.0), vec2(Params.imageSize) - 1.0));
            color = fetchInput(tileIndex, samplePx);
        }
    }

    imageStore(outImage, pixel, vec4(color, 1.0));
}
