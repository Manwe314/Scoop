#version 460
#extension GL_EXT_nonuniform_qualifier : enable
// ------ Cpu side passed Objects -------
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D outImage;

struct SBVHNode {
    vec4 bbMin_left__left_start;
    vec4 bbMax_left__left_count;
    vec4 bbMin_right__right_start;
    vec4 bbMax_right__right_count;
};

struct MollerTriangle {
    vec4 vertex_0;
    vec4 edge_vec1;
    vec4 edge_vec2;
};

struct ShadingTriangle {
    vec4 vertexNormal0_uv;
    vec4 vertexNormal1_uv;
    vec4 vertexNormal2_uv;
    vec4 texture_materialId;
};

struct MaterialGPU {
    vec4 baseColor_opacity;
    vec4 F0_ior_rough;
    vec4 emission_flags;
    vec4 textureId;
};

layout(set = 0, binding = 1, std430) readonly buffer BVHNodesBuf { SBVHNode        bvhNodes[]; };
layout(set = 0, binding = 2, std430) readonly buffer MollerBuf   { MollerTriangle  triangles[]; };
layout(set = 0, binding = 3, std430) readonly buffer ShadeBuf    { ShadingTriangle shadingTris[]; };
layout(set = 0, binding = 4, std430) readonly buffer MtlBuf      { MaterialGPU     materials[];  };

layout(set = 0, binding = 5, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;
    uint  _pad;
} Params;

struct TLASNodeGPU {
    vec4  bbMin;           
    vec4  bbMax;          
    uvec4 meta;            // x=first, y=count, z=left, w=right
};

struct InstanceDataGPU {
    vec4 modelToWorld0;
    vec4 modelToWorld1;
    vec4 modelToWorld2;

    vec4 worldToModel0;
    vec4 worldToModel1;
    vec4 worldToModel2;

    vec4 aabbMin;
    vec4 aabbMax;

    uvec4 bases01; // x=nodeBase, y=triBase, z=shadeTriBase, w=materialBase
    uvec4 bases23; // x=textureBase, y=sbvhRoot
};

layout(set = 0, binding = 6, std430) readonly buffer TLASNodesBuf { TLASNodeGPU      tlasNodes[];   };
layout(set = 0, binding = 7, std430) readonly buffer InstanceBuf  { InstanceDataGPU  instances[];   };
layout(set = 0, binding = 8, std430) readonly buffer InstIdxBuf { uint instanceIndices[]; };
layout(set = 0, binding = 9) uniform sampler2D textures2D[];

// ---------- RayTracing Engine ----------


//~~~~~~~~~~~~~ comp specific data structs ~~~~~~~~~~~~~
struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 color;
};

struct Hit {
    float dist_to_hit; //in world space
    uint instanceIndex;
    uint primitiveIndex;
    vec2 barrycentricUV;
};

struct TlasTraverse {
    uint instanceId;
    float tNear;
};

//~~~~~~~~~~~~~ helpers ~~~~~~~~~~~~~

float rand(const in uvec2 pixel)
{
    float time = Params.camPos_time.w;
    return fract(sin(dot(pixel + time, vec2(12.9898, 78.233))) * 43758.5453);
}

void swap(inout float a, inout float b)
{
    float temp = a;
    a = b;
    b = temp;
}

vec3 affineTransformPoint(const in vec3 point, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    return vec3(dot(row0.xyz, point) + row0.w,
                dot(row1.xyz, point) + row1.w,
                dot(row2.xyz, point) + row2.w);
}

vec3 affineTransformDirection(const in vec3 direction, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    return vec3(dot(row0.xyz, direction),
                dot(row1.xyz, direction),
                dot(row2.xyz, direction));
}

Ray affineTransformRay(const in Ray ray, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    Ray newRay;
    newRay.color = ray.color;
    newRay.origin = affineTransformPoint(ray.origin, row0, row1, row2); 
    newRay.direction = affineTransformDirection(ray.direction, row0, row1, row2);
    return newRay;
}

vec3 interpNormal(const in vec3 normal0, const in vec3 normal1, const in vec3 normal2, const in float u, const in float v)
{
    float w = 1.0 - u - v;
    vec3 normal = w * normal0 + u * normal1 + v * normal2;
    return normalize(normal);
}

vec4 getTextureSample(const in uint textureIndex, inout Hit hit, const in vec2 vt0, const in vec2 vt1, const in vec2 vt2)
{
    if (textureIndex == 0xFFFFFFFFu)
        return vec4(1.0);

    vec2 UV = (1.0 - hit.barrycentricUV.x - hit.barrycentricUV.y) * vt0 + hit.barrycentricUV.x * vt1 + hit.barrycentricUV.y * vt2;
    UV.y = 1.0 - UV.y;
    // uint index = nonuniformEXT(textureIndex);
    return textureLod(textures2D[textureIndex], UV, 0.0);
}


void sortTLASLeafHits(inout TlasTraverse leaves[30], int count)
{
    for (int i = 1; i < count; i++)
    {
        TlasTraverse key = leaves[i];
        int j = i - 1;
        while (j >= 0 && leaves[j].tNear > key.tNear)
        {
            leaves[j + 1] = leaves[j];
            j--;
        }
        leaves[j + 1] = key;
    }
}




//temp
vec3 hsv2rgb(vec3 c) { // compact HSV->RGB
    vec3 p = abs(fract(c.x + vec3(0,2,4)/6.0)*6.0 - 3.0);
    return c.z * mix(vec3(1.0), clamp(p-1.0,0.0,1.0), c.y);
}
vec3 directionHue(vec3 n) {
    n = normalize(n);
    float az = atan(n.z, n.x);                 // [-pi,pi]
    float el = asin(clamp(n.y, -1.0, 1.0));    // [-pi/2,pi/2]
    float H = (az / (2.0*3.14159265)) + 0.5;   // [0,1]
    float S = 0.7;
    float V = 0.5 + 0.5 * (el/(0.5*3.14159265)); // brighter when pointing up
    return hsv2rgb(vec3(H,S,V));
}

//~~~~~~~~~~~~~ core functions ~~~~~~~~~~~~~
Ray generateRay(const in uvec2 pixel)
{
    vec2 UV = (vec2(pixel) + 0.5) / vec2(Params.imageSize);
    UV.y = 1 - UV.y;

    vec2 normalisedDeviceCoordinate = UV * 2.0 - 1.0;

    vec4 nearPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 0.0, 1.0);
    vec4 farPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 1.0, 1.0);

    vec3 point0 = nearPoint.xyz / nearPoint.w;
    vec3 point1 = farPoint.xyz / farPoint.w;

    Ray ray;
    ray.origin = Params.camPos_time.xyz;
    ray.direction = normalize(point1 - point0);
    ray.color = vec3(0.0);
    return ray;
}

bool intersectingAABB(const in Ray ray, const in vec3 bbMin, const in vec3 bbMax, const in float tMin, const in float tMax, inout float tEnter, inout float tExit)
{
    //ray forula for point P along the ray at some distance t from origin:
    // P(t) = O + t * D where O is Origin vec3 and D is Normalized vec3 Direction. 
    float t0 = tMin;
    float t1 = tMax;

    for (int axis = 0; axis < 3; axis++)
    {
        float originI = ray.origin[axis];
        float directionI = ray.direction[axis];
        float minBoxA = bbMin[axis];
        float maxBoxA = bbMax[axis];

        if (abs(directionI) <= 1e-8)
        {
            if (originI < minBoxA || originI > maxBoxA)
                return false;

        }
        else
        {
            float inverseDirectionI = 1.0 / directionI;
            float tNearA = (minBoxA - originI) * inverseDirectionI;
            float tFarA = (maxBoxA - originI) * inverseDirectionI;
            if (tNearA > tFarA)
                swap(tNearA, tFarA);
            
            t0 = tNearA > t0 ? tNearA : t0;
            t1 = tFarA < t1 ? tFarA : t1;
            if (t1 < t0)
                return false;
        }
    }
    tEnter = t0;
    tExit = t1;
    return (tExit >= tMin) && (tEnter <= tMax);
}

bool moller_trumbore(const in Ray ray, inout Hit hit, const in vec3 vertex_0, const in vec3 edge_1, const in vec3 edge_2, inout float min_distance)
{
    //algorithm final form:
    /*
       | t |                     | Q . edge2 |
       | u | = 1 / (P . edge1) * |   P . T   |
       | v |                     |   Q . D   |
    */
    //where:
    /*
        D - Nromalized ray direction
        P = D X edge2
        Q = T X edge1
        T = O - vertex0
        O - ray Origin
    */
    vec3 P = cross(ray.direction, edge_2);
    float det = dot(P, edge_1);

    if (abs(det) <= 1e-8)
        return false;
    
    float inverse_det = 1 / det;
    vec3 T = ray.origin - vertex_0;

    float u = dot(T, P) * inverse_det;
    if (u < 0.0 || u > 1.0)
        return false;
    
    vec3 Q = cross(T, edge_1);
    float v = dot(ray.direction, Q) * inverse_det;
    if (v < 0.0 || (v + u) > 1.0)
        return false;
    float t = dot(edge_2, Q) * inverse_det;
    if (t < 1e-8)
        return false;
    if (t < min_distance)
    {
        min_distance = t;
        hit.barrycentricUV.x = u;
        hit.barrycentricUV.y = v;
        return true;
    }
    return false;
}

void traverseTLAS(const in Ray ray, inout Hit hit , const in uint root, inout TlasTraverse instancesOut[30], const in float tEnter, const in float tExit, out int outPutPointer)
{
    uint stack[30];
    int stackPointer = 0;
    stack[stackPointer] = root;
    outPutPointer = 0;
        

    while (stackPointer >= 0)
    {
        float tNearLeft, tNearRight, tFarLeft, tFarRight;

        uvec4 meta = tlasNodes[stack[stackPointer]].meta;
        if (meta.y > 0)
        {
            uint instanceI = instanceIndices[meta.x];
            Ray modelRay = affineTransformRay(ray, instances[instanceI].worldToModel0, instances[instanceI].worldToModel1, instances[instanceI].worldToModel2);
            vec3 bbmin = vec3(instances[instanceI].aabbMin);
            vec3 bbmax = vec3(instances[instanceI].aabbMax);
            float tNear, tFar;
            if (intersectingAABB(modelRay, bbmin, bbmax, tEnter, tExit, tNear, tFar)) {
                if (outPutPointer < 30)
                {
                    instancesOut[outPutPointer].instanceId = instanceI;
                    instancesOut[outPutPointer].tNear = tNear;
                    outPutPointer++;
                }
            }
        
            stackPointer--;
            continue;
        }
        TLASNodeGPU leftNode = tlasNodes[meta.z];
        TLASNodeGPU rightNode = tlasNodes[meta.w];

        vec3 left_bbMin = vec3(leftNode.bbMin);
        vec3 left_bbMax = vec3(leftNode.bbMax);

        vec3 right_bbMin = vec3(rightNode.bbMin);
        vec3 right_bbMax = vec3(rightNode.bbMax);

        bool hitLeft = intersectingAABB(ray, left_bbMin, left_bbMax, tEnter, tExit, tNearLeft, tFarLeft);
        bool hitRight = intersectingAABB(ray, right_bbMin, right_bbMax, tEnter, tExit, tNearRight, tFarRight);

        if (hitLeft && hitRight)
        {
            if (tNearLeft > tNearRight)
            {
                stack[stackPointer] = meta.z;
                stackPointer++;
                stack[stackPointer] = meta.w;
            }
            else
            {
                stack[stackPointer] = meta.w;
                stackPointer++;
                stack[stackPointer] = meta.z;
            }
        }
        else if (hitLeft)
            stack[stackPointer] = meta.z;
        else if (hitRight)
            stack[stackPointer] = meta.w;
        else
            stackPointer--;
    }
    hit.instanceIndex = 0xFFFFFFFFu;
}


void traverseBLAS(const in Ray ray, inout Hit hit, const in uint nodeOffset, const in uint triBase, inout float closestT)
{
    const float ORDER_EPS = 1e-6;

    uint stack[64];
    int  stackPointer = 0;
    stack[stackPointer] = nodeOffset;


    while (stackPointer >= 0)
    {

        float tNearLeft, tNearRight, tFarLeft, tFarRight;

        SBVHNode node = bvhNodes[stack[stackPointer]];

        vec4 left_count_n_max = node.bbMax_left__left_count;
        vec3 left_bbMax       = vec3(left_count_n_max);
        uint left_count       = floatBitsToUint(left_count_n_max.w);

        vec4 left_start_n_min = node.bbMin_left__left_start;
        vec3 left_bbMin       = vec3(left_start_n_min);
        uint left_start       = floatBitsToUint(left_start_n_min.w);

        if (left_count != 0xFFFFFFFFu)
        {
            float tNearLeaf, tFarLeaf;
            bool leafHit = intersectingAABB(ray, left_bbMin, left_bbMax, 1e-6, closestT, tNearLeaf, tFarLeaf);
            if (!leafHit || tNearLeaf >= closestT)
            {
                stackPointer--;
                continue;
            }

            float min_distance = closestT;
            uint  primIndex    = 0xFFFFFFFFu;

            for (uint i = 0; i < left_count; i++)
            {
                uint prim = left_start + triBase + i;
                MollerTriangle triangle = triangles[prim];
                if (moller_trumbore(ray, hit,
                                    vec3(triangle.vertex_0),
                                    vec3(triangle.edge_vec1),
                                    vec3(triangle.edge_vec2),
                                    min_distance))
                {
                    primIndex = prim;
                }
            }
            if (primIndex != 0xFFFFFFFFu)
            {
                closestT = min_distance;
                hit.primitiveIndex = primIndex;
            }
            stackPointer--;
            continue;
        }

        vec3 right_bbMax = vec3(node.bbMax_right__right_count);

        vec4 right_start_n_Min = node.bbMin_right__right_start;
        vec3 right_bbMin       = vec3(right_start_n_Min);
        uint right_start       = floatBitsToUint(right_start_n_Min.w);


        bool hitLeft  = intersectingAABB(ray, left_bbMin,  left_bbMax,  1e-6, closestT, tNearLeft,  tFarLeft);
        bool hitRight = intersectingAABB(ray, right_bbMin, right_bbMax, 1e-6, closestT, tNearRight, tFarRight);

        if (!hitLeft && !hitRight)
        {
            stackPointer--;
            continue;
        }

        if (hitLeft && hitRight)
        {
            bool leftIsNear = (abs(tNearLeft - tNearRight) > ORDER_EPS) ? (tNearLeft < tNearRight) : (left_start < right_start);

            uint nearIdx = leftIsNear ? (left_start  + nodeOffset) : (right_start + nodeOffset);
            uint farIdx  = leftIsNear ? (right_start + nodeOffset) : (left_start  + nodeOffset);

            stack[stackPointer] = farIdx;
            stackPointer++;
            stack[stackPointer] = nearIdx;
        }
        else if (hitLeft)
        {
            stack[stackPointer] = left_start + nodeOffset;
        }
        else
        {
            stack[stackPointer] = right_start + nodeOffset;
        }
    }
}



// ~~~~~~~~~~~~~ main ~~~~~~~~~~~~~

void main()
{
    //early pixel gate && get pixel XY.
    uvec2 pixel = gl_GlobalInvocationID.xy;
    if (pixel.x >= Params.imageSize.x || pixel.y >= Params.imageSize.y)
        return;

    bool viewBB = Params._pad == 69 ? true : false;
    
    uint rootId = Params.rootIndex;
    TlasTraverse TLASInstanceLeafIDs[30];

    
    
    float tEnter, tExit;

    //make the main ray.
    Ray ray = generateRay(pixel);
    //if we hit the root TLAS node i.e ANYTHING in the scene do the work, otherwise we missed everything
    if (intersectingAABB(ray, vec3(tlasNodes[rootId].bbMin), vec3(tlasNodes[rootId].bbMax), 1e-8, 1e30, tEnter, tExit))
    {
        //russian rulette termination float
        float terminate = 0.0;
        Hit hit = Hit(1e30, 0xFFFFFFFFu, 0xFFFFFFFFu, vec2(0.0));
        //main work loop.
        while (true)
        {
            int leafCount = 0;
            traverseTLAS(ray, hit, rootId, TLASInstanceLeafIDs, tEnter, tExit, leafCount);
            sortTLASLeafHits(TLASInstanceLeafIDs, leafCount);
            float closestT = 1e30;
            for (int i = 0; i < leafCount; i++)
            {
                uint instanceId = TLASInstanceLeafIDs[i].instanceId;
                Ray modelRay = affineTransformRay(ray, instances[instanceId].worldToModel0, instances[instanceId].worldToModel1, instances[instanceId].worldToModel2);

                traverseBLAS(modelRay, hit,
                    instances[instanceId].bases01.x,
                    instances[instanceId].bases01.y,
                    closestT
                );

                if (hit.primitiveIndex != 0xFFFFFFFFu) {
                    hit.instanceIndex = instanceId;
                    break;
                }
            }
            if (hit.instanceIndex == 0xFFFFFFFFu && hit.primitiveIndex == 0xFFFFFFFFu)
                ray.color = vec3(1.0);
            else if (hit.instanceIndex != 0xFFFFFFFFu && hit.primitiveIndex == 0xFFFFFFFFu)
                ray.color = vec3(1.0);
            else if (hit.instanceIndex != 0xFFFFFFFFu && hit.primitiveIndex != 0xFFFFFFFFu)
            {
                ShadingTriangle trinagle = shadingTris[hit.primitiveIndex];
                vec4 vertex0_data = trinagle.vertexNormal0_uv;
                vec4 vertex1_data = trinagle.vertexNormal1_uv;
                vec4 vertex2_data = trinagle.vertexNormal2_uv;
                vec4 texture_material = trinagle.texture_materialId;

                vec2 vt0 = vec2(vertex0_data.w, texture_material.x);
                vec2 vt1 = vec2(vertex1_data.w, texture_material.y);
                vec2 vt2 = vec2(vertex2_data.w, texture_material.z);

                uint materialIndex = floatBitsToUint(texture_material.w);
                materialIndex += instances[hit.instanceIndex].bases01.w;


                uint textureIndex = floatBitsToUint(materials[materialIndex].textureId.x);
                ray.color = vec3(getTextureSample(textureIndex, hit, vt0, vt1, vt2));
                if (ray.color == vec3(1.0))
                {
                    vec3 normal = interpNormal(vertex0_data.xyz, vertex1_data.xyz, vertex2_data.xyz,
                                               hit.barrycentricUV.x, hit.barrycentricUV.y);
                    bool frontFace = dot(normal, -ray.direction) > 0.0;
                    vec3 adjustedNormal = frontFace ? normal : -normal;
                    ray.color = directionHue(normal);
                }
            }

            //recursive traversal of TLAS
            // miss logic or BLAS hit
            // recursive traversal of BLAS
            // miss logic or trinagle hit
            // task based sampling over OMEGA hemisphere
            // update Ray color based on sampling output


            // update Ray origin and direction based on 
            if (terminate < 1.0)
                break;
            else
                break;
        }
    }
    else
        ray.color = vec3(1.0);

    
    imageStore(outImage, ivec2(pixel), vec4(ray.color, 1.0));
}
