#version 460
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D outImage;

struct SBVHNode {
    vec4 bbMin_left__left_start;
    vec4 bbMax_left__left_count;
    vec4 bbMin_right__right_start;
    vec4 bbMax_right__right_count;
};

struct MollerTriangle {
    vec4 v0;
    vec4 e1;
    vec4 e2;
    vec4 n_mat;
};

struct ShadingTriangle {
    vec4 n0_uv;
    vec4 n1_uv;
    vec4 n2_uv;
};

struct MaterialGPU {
    vec4 baseColor_opacity;
    vec4 F0_ior_rough;
    vec4 emission_flags;
    vec4 reserved;
};

struct Ray {
    vec3 o;
    vec3 d;
};

layout(set = 0, binding = 1, std430) readonly buffer BVHNodesBuf { SBVHNode nodes[]; };
layout(set = 0, binding = 2, std430) readonly buffer MollerBuf   { MollerTriangle triangles[]; };
layout(set = 0, binding = 3, std430) readonly buffer ShadeBuf    { ShadingTriangle shadingTriangles[]; };
layout(set = 0, binding = 4, std430) readonly buffer MtlBuf      { MaterialGPU materials[]; };

layout(set = 0, binding = 5, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;
    uint  _pad;
} Params;


uint u_from_float(float f) { return floatBitsToUint(f); }

uint left_start (SBVHNode n) { return u_from_float(n.bbMin_left__left_start.w); }
uint left_count (SBVHNode n) { return u_from_float(n.bbMax_left__left_count.w); }
uint right_start(SBVHNode n) { return u_from_float(n.bbMin_right__right_start.w); }
uint right_count(SBVHNode n) { return u_from_float(n.bbMax_right__right_count.w); }

uint tri_materialId(MollerTriangle t) { return u_from_float(t.n_mat.w); }

// -------------------------------------------------------------------------------

Ray makeRay(uvec2 pix)
{
    vec2 uv = (vec2(pix) + 0.5) / vec2(Params.imageSize);
    uv.y = 1.0 - uv.y;
    // NDC in [-1,1]
    vec2 ndc = uv * 2.0 - 1.0;

    // Reconstruct two clip-space points along the ray: z = 0 near, z = 1 far
    vec4 p0 = Params.viewProjInv * vec4(ndc, 0.0, 1.0);
    vec4 p1 = Params.viewProjInv * vec4(ndc, 1.0, 1.0);
    p0 /= p0.w; p1 /= p1.w;

    Ray r;
    r.o = Params.camPos_time.xyz;           // camera position
    r.d = normalize(p1.xyz - p0.xyz);       // forward through pixel
    return r;
}

bool intersectAABB(vec3 bmin, vec3 bmax, Ray r, out float tNear, out float tFar)
{
    vec3 invD = 1.0 / r.d;
    vec3 t0 = (bmin - r.o) * invD;
    vec3 t1 = (bmax - r.o) * invD;
    vec3 tmin3 = min(t0, t1);
    vec3 tmax3 = max(t0, t1);
    tNear = max(max(tmin3.x, tmin3.y), tmin3.z);
    tFar  = min(min(tmax3.x, tmax3.y), tmax3.z);
    return tFar >= max(tNear, 0.0);
}

bool intersectTriMT(const MollerTriangle t, Ray r, out float tHit, out float u, out float v)
{
    // Möller–Trumbore with precomputed e1/e2 and v0
    vec3 pvec = cross(r.d, t.e2.xyz);
    float det = dot(t.e1.xyz, pvec);
    // backface cull? if yes: if (det <= 1e-8) return false;
    if (abs(det) < 1e-8) return false;
    float invDet = 1.0 / det;

    vec3 tvec = r.o - t.v0.xyz;
    u = dot(tvec, pvec) * invDet; if (u < 0.0 || u > 1.0) return false;

    vec3 qvec = cross(tvec, t.e1.xyz);
    v = dot(r.d, qvec) * invDet;  if (v < 0.0 || u + v > 1.0) return false;

    tHit = dot(t.e2.xyz, qvec) * invDet;
    return tHit > 0.0;
}

// Pick near-first child order using the slab tNear to each AABB
void orderChildrenByDistance(
    float tNearL, float tNearR, out uint firstIdx, out uint secondIdx, uint idxL, uint idxR)
{
    bool leftFirst = (tNearL <= tNearR);
    firstIdx  = leftFirst ? idxL : idxR;
    secondIdx = leftFirst ? idxR : idxL;
}

// Decide if a child entry is a leaf or internal.
// --- ADAPT THIS to your packing: here we assume count>0 => leaf with that many tris starting at start; count==0 => internal node index in start.
bool isLeaf(uint start, uint count) { return count != 0xFFFFFFFFu; }

// ---------- main ----------
void main()
{
    uvec2 pix = gl_GlobalInvocationID.xy;
    if (pix.x >= Params.imageSize.x || pix.y >= Params.imageSize.y) return;

    Ray ray = makeRay(pix);

    const uint INVALID = 0xffffffffu;
    const int STACK_MAX = 64;           // adjust if your BVH can get deeper
    uint stack[STACK_MAX];
    int sp = 0;

    stack[sp++] = Params.rootIndex;

    float closestT = 1e30;
    uint  hitTri   = INVALID;
    float hitU = 0.0, hitV = 0.0;

    // traversal
    while (sp > 0)
    {
        uint ni = stack[--sp];
        SBVHNode n = nodes[ni];

        // Left child data
        vec3 lmin = n.bbMin_left__left_start.xyz;
        vec3 lmax = n.bbMax_left__left_count.xyz;
        uint lStart = left_start(n);
        uint lCount = left_count(n);

        // Right child data
        vec3 rmin = n.bbMin_right__right_start.xyz;
        vec3 rmax = n.bbMax_right__right_count.xyz;
        uint rStart = right_start(n);
        uint rCount = right_count(n);

        float tNL, tFL, tNR, tFR;
        bool hitL = intersectAABB(lmin, lmax, ray, tNL, tFL) && (tNL <= closestT);
        bool hitR = intersectAABB(rmin, rmax, ray, tNR, tFR) && (tNR <= closestT);

        if (!hitL && !hitR) continue;

        // Handle leaves vs internal
        uint firstIdx, secondIdx, firstStart, firstCount, secondStart, secondCount;

        // compute near-first ordering
        if (hitL && hitR)
            orderChildrenByDistance(tNL, tNR, firstIdx, secondIdx, 0u, 1u);
        else
            firstIdx = hitL ? 0u : 1u, secondIdx = INVALID;

        // Expand “first”
        if (firstIdx == 0u) { firstStart = lStart; firstCount = lCount; }
        else                { firstStart = rStart; firstCount = rCount; }

        // Expand “second” (if any)
        if (secondIdx != INVALID) {
            if (secondIdx == 0u) { secondStart = lStart; secondCount = lCount; }
            else                 { secondStart = rStart; secondCount = rCount; }
        }

        // Push/visit logic
        // INTERNAL: count==0 -> child node index in start
        // LEAF    : count>0  -> triangle range [start, start+count)
        if (isLeaf(firstStart, firstCount)) {
            // intersect triangles in first leaf
            for (uint t = 0u; t < firstCount; ++t) {
                uint triId = firstStart + t;
                float tHit, u, v;
                if (intersectTriMT(triangles[triId], ray, tHit, u, v) && tHit < closestT) {
                    closestT = tHit; hitTri = triId; hitU = u; hitV = v;
                }
            }
        } else {
            // internal: push child node index
            if (sp < STACK_MAX) stack[sp++] = firstStart;  // child node index
        }

        if (secondIdx != INVALID) {
            if (isLeaf(secondStart, secondCount)) {
                for (uint t = 0u; t < secondCount; ++t) {
                    uint triId = secondStart + t;
                    float tHit, u, v;
                    if (intersectTriMT(triangles[triId], ray, tHit, u, v) && tHit < closestT) {
                        closestT = tHit; hitTri = triId; hitU = u; hitV = v;
                    }
                }
            } else {
                if (sp < STACK_MAX) stack[sp++] = secondStart;
            }
        }
    }

    vec3 color;
    if (hitTri == INVALID) {
        // miss: sky gradient
        color = vec3(1, 1, 1);
    } else {
        // interpolate normal using barycentrics (w = 1-u-v)
        float w = 1.0 - hitU - hitV;
        ShadingTriangle st = shadingTriangles[hitTri];

        vec3 n = normalize(st.n0_uv.xyz * w +
                           st.n1_uv.xyz * hitU +
                           st.n2_uv.xyz * hitV);

        // pretty color from normal
        color = 0.5 * (n * 0.999 + 1.0);
        // or use material tint:
        // color *= materials[tri_materialId(triangles[hitTri])].baseColor_opacity.rgb;
    }
    





    imageStore(outImage, ivec2(pix), vec4(color, 1.0));
}

