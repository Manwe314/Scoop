#version 460
// ------ Cpu side passed Objects -------
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D outImage;

struct SBVHNode {
    vec4 bbMin_left__left_start;
    vec4 bbMax_left__left_count;
    vec4 bbMin_right__right_start;
    vec4 bbMax_right__right_count;
};

struct MollerTriangle {
    vec4 vertex_0;
    vec4 edge_vec1;
    vec4 edge_vec2;
    vec4 normal_mat;
};

struct ShadingTriangle {
    vec4 vertexNormal0_uv;
    vec4 vertextNormal1_uv;
    vec4 vertexNormal2_uv;
};

struct MaterialGPU {
    vec4 baseColor_opacity;
    vec4 F0_ior_rough;
    vec4 emission_flags;
    vec4 textureId;
};

layout(set = 0, binding = 1, std430) readonly buffer BVHNodesBuf { SBVHNode        bvhNodes[]; };
layout(set = 0, binding = 2, std430) readonly buffer MollerBuf   { MollerTriangle  triangles[]; };
layout(set = 0, binding = 3, std430) readonly buffer ShadeBuf    { ShadingTriangle shadingTris[]; };
layout(set = 0, binding = 4, std430) readonly buffer MtlBuf      { MaterialGPU     materials[];  };

layout(set = 0, binding = 5, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;
    uint  _pad;
} Params;

struct TLASNodeGPU {
    vec4  bbMin;           
    vec4  bbMax;          
    uvec4 meta;            // x=first, y=count, z=left, w=right
};

struct InstanceDataGPU {
    vec4 modelToWorld0;
    vec4 modelToWorld1;
    vec4 modelToWorld2;

    vec4 worldToModel0;
    vec4 worldToModel1;
    vec4 worldToModel2;

    vec4 aabbMin;
    vec4 aabbMax;

    uvec4 bases01; // x=nodeBase, y=triBase, z=shadeTriBase, w=materialBase
    uvec4 bases23; // x=textureBase, y=sbvhRoot
};

layout(set = 0, binding = 6, std430) readonly buffer TLASNodesBuf { TLASNodeGPU      tlasNodes[];   };
layout(set = 0, binding = 7, std430) readonly buffer InstanceBuf  { InstanceDataGPU  instances[];   };
layout(set = 0, binding = 8, std430) readonly buffer InstIdxBuf { uint instanceIndices[]; };

// ---------- RayTracing Engine ----------


//~~~~~~~~~~~~~ comp specific data structs ~~~~~~~~~~~~~
struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 color;
};

struct Hit {
    float dist_to_hit; //in world space
    uint instanceIndex;
    uint primitiveIndex;
    vec2 barrycentricUV;
};

struct AABB {
    vec3 bbMin;
    vec3 bbMax;
};


//~~~~~~~~~~~~~ helpers ~~~~~~~~~~~~~

float rand(uvec2 pixel)
{
    float time = Params.camPos_time.w;
    return fract(sin(dot(pixel + time, vec2(12.9898, 78.233))) * 43758.5453);
}

void swap(inout float a, inout float b)
{
    float temp = a;
    a = b;
    b = temp;
}



//~~~~~~~~~~~~~ core functions ~~~~~~~~~~~~~
Ray generateRay(uvec2 pixel)
{
    vec2 UV = (vec2(pixel) + 0.5) / vec2(Params.imageSize);
    UV.y = 1 - UV.y;

    vec2 normalisedDeviceCoordinate = UV * 2.0 - 1.0;

    vec2 nearPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 0.0, 1.0);
    vec2 farPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 1.0, 1.0);

    vec3 point0 = nearPoint.xyz / nearPoint.w;
    vec3 point1 = farPoint.xyz / farPoint.w;

    Ray ray;
    ray.origin = Params.camPos_time.xyz;
    ray.direction = normalize(point1 - point0);
    ray.color = vec3(0.0);
    return ray;
}

bool inersectingAABB(Ray ray, AABB aabb, float tMin, float tMax, inout float tEnter, inout float tExit)
{
    //ray forula for point P along the ray at some distance t from origin:
    // P(t) = O + t * D where O is Origin vec3 and D is Normalized vec3 Direction. 
    float t0 = tMin;
    float t1 = tMax;

    for (int axis = 0; axis < 3; axis++)
    {
        float originI = ray.origin[axis];
        float directionI = ray.direction[axis];
        float minBoxA = aabb.bbMin[axis];
        float maxBoxA = aabb.bbMax[axis];

        if (abs(directionI) <= 1e-8f)
            if (originI < minBoxA || originI > maxBoxA)
                return false;
        else
        {
            float inverseDirectionI = 1.0 / directionI;
            float tNearA = (minBoxA - originI) * inverseDirectionI;
            float tFarA = (maxBoxA - originI) * inverseDirectionI;
            if (tNearA > tFarA)
                swap(tNearA, tFarA);
            
            t0 = tNearA > t0 ? tNearA : t0;
            t1 = tFarA < t1 ? tFarA : t1;
            if (t1 < t0)
                return false;
        }
    }
    tEnter = t0;
    tExit = t1;
    return (tExit >= tMin) && (tEnter <= tMax);
}

Hit traverseTLAS(Ray ray, inout TLASNodeGPU stack[], inout int stackPointer, float tEnter, float tExit)
{
    TLASNodeGPU node = stack[stackPointer];

    Hit hit = Hit(1e30, 0xFFFFFFFFu, 0xFFFFFFFFu, vec2(0.0));

    while (stackPointer >= 0)
    {
        float tNearLeft, tNearRight, tFarLeft, tFarRight;
        if (node.meta.y > 0)
        {
            hit.instanceIndex = instanceIndices[node.meta.x];
            stackPointer--;
            return hit;
        }
        TLASNodeGPU left = tlasNodes[node.meta.z];
        TLASNodeGPU right = tlasNodes[node.meta.w];
        AABB leftAABB = AABB(vec3(left.bbMin), vec3(left.bbMax));
        AABB rightAABB = AABB(vec3(right.bbMin), vec3(right.bbMax));
        bool hitLeft = inersectingAABB(ray, leftAABB, tEnter, tExit, tNearLeft, tFarLeft);
        bool hitRight = inersectingAABB(ray, rightAABB, tEnter, tExit, tNearRight, tFarRight);

        if (hitLeft && hitRight)
        {
            if (tNearLeft > tNearRight)
            {
                stack[stackPointer] = left;
                stackPointer++;
                stack[stackPointer] = right;
            }
            else
            {
                stack[stackPointer] = right;
                stackPointer++;
                stack[stackPointer] = left;
            }
        }
        else if (hitLeft)
            stack[stackPointer] = left;
        else if (hitRight)
            stack[stackPointer] = right;
        else
            stackPointer--;

        if (stackPointer >= 0)
            node = stack[stackPointer];
    }
    return hit;
}


// ~~~~~~~~~~~~~ main ~~~~~~~~~~~~~

void main()
{
    //early pixel gate && get pixel XY.
    uvec2 pixel = gl_GlobalInvocationID.xy;
    if (pixel.x >= Params.imageSize.x || pixel.y >= Params.imageSize.y)
        return;

    bool viewBB = Params._pad == 69 ? true : false;
    
    //Init TLAS with root node to begin everything
    TLASNodeGPU TLASStack[30];
    int TLASStackPointer = 0;
    stack[stackPointer] = tlasNodes[Params.rootIndex];
    AABB aabb = AABB(vec3(stack[stackPointer].bbMin), vec3(stack[stackPointer].bbMax));
    float tEnter, tExit;

    //make the main ray.
    Ray ray = generateRay(pixel);
    //if we hit the root TLAS node i.e ANYTHING in the scene do the work, otherwise we missed everything
    if (inersectingAABB(ray, aabb, 1e-8f, 1e30f, tEnter, tExit))
    {
        //russian rulette termination float
        float terminate = 0.0;
        //main work loop.
        while (1)
        {
            //record TLAS closest child hit. 
            Hit hit = traverseTLAS(ray, TLASRoot, TLASStackPointer, tEnter, tExit)
            if (hit.instanceIndex == 0xFFFFFFFFu)
            {
                ray.color = vec3(1.0);
                break;
            }
            //recursive traversal of TLAS
            // miss logic or BLAS hit
            // recursive traversal of BLAS
            // miss logic or trinagle hit
            // task based sampling over OMEGA hemisphere
            // update Ray color based on sampling output
            if (terminate < 1.0)
                // update Ray origin and direction based on 
            else
                break;
        }
    }
    else
        ray.color = vec3(1.0);
    
    imageStore(outImage, ivec2(pix), vec4(ray.color, 1.0));
}
