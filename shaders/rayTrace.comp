#version 460
#extension GL_EXT_nonuniform_qualifier : enable
// ------ Cpu side passed Objects -------
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D outImage;

struct SBVHNode {
    vec4 bbMin_left__left_start;
    vec4 bbMax_left__left_count;
    vec4 bbMin_right__right_start;
    vec4 bbMax_right__right_count;
};

struct MollerTriangle {
    vec4 vertex_0;
    vec4 edge_vec1;
    vec4 edge_vec2;
};

struct ShadingTriangle {
    vec4 vertexNormal0_uv;
    vec4 vertexNormal1_uv;
    vec4 vertexNormal2_uv;
    vec4 texture_materialId;
};

struct MaterialGPU {
    vec4 baseColor_opacity;
    vec4 F0_ior_rough;
    vec4 emission_flags;
    vec4 textureId;
};

layout(set = 0, binding = 1, std430) readonly buffer BVHNodesBuf { SBVHNode        bvhNodes[]; };
layout(set = 0, binding = 2, std430) readonly buffer MollerBuf   { MollerTriangle  triangles[]; };
layout(set = 0, binding = 3, std430) readonly buffer ShadeBuf    { ShadingTriangle shadingTris[]; };
layout(set = 0, binding = 4, std430) readonly buffer MtlBuf      { MaterialGPU     materials[];  };

layout(set = 0, binding = 5, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;
    uint  flags;
} Params;

struct TLASNodeGPU {
    vec4  bbMin;           
    vec4  bbMax;          
    uvec4 meta;            // x=first, y=count, z=left, w=right
};

struct InstanceDataGPU {
    vec4 modelToWorld0;
    vec4 modelToWorld1;
    vec4 modelToWorld2;

    vec4 worldToModel0;
    vec4 worldToModel1;
    vec4 worldToModel2;

    vec4 aabbMin;
    vec4 aabbMax;

    uvec4 bases01; // x=nodeBase, y=triBase, z=shadeTriBase, w=materialBase
    uvec4 bases23; // x=textureBase, y=sbvhRoot
};

layout(set = 0, binding = 6, std430) readonly buffer TLASNodesBuf { TLASNodeGPU      tlasNodes[];   };
layout(set = 0, binding = 7, std430) readonly buffer InstanceBuf  { InstanceDataGPU  instances[];   };
layout(set = 0, binding = 8, std430) readonly buffer InstIdxBuf { uint instanceIndices[]; };
layout(set = 0, binding = 9) uniform sampler2D textures2D[];

// ---------- RayTracing Engine ----------


//~~~~~~~~~~~~~ comp specific data structs ~~~~~~~~~~~~~
struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 color;
};

struct Hit {
    float dist_to_hit;
    float world_dist_to_hit;
    uint instanceIndex;
    uint primitiveIndex;
    vec2 barrycentricUV;
};

const uint FLAG_B            = 1u << 31;
const uint FLAG_INSTANCE_SEL = 1u << 30;
const uint B_INTERP_SHIFT    = 20u;
const uint B_INTERP_MASK     = 0x3FFu << B_INTERP_SHIFT;
const uint MASK_INSTANCE_IDX = 0xFu;


//~~~~~~~~~~~~~ helpers ~~~~~~~~~~~~~

uint wang_hash(uint s)
{
    s = (s ^ 61u) ^ (s >> 16);
    s *= 9u;
    s = s ^ (s >> 4);
    s *= 0x27d4eb2du;
    s = s ^ (s >> 15);
    return s;
}

uint xorshift(inout uint state)
{
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    return state;
}

float rand(inout uint state)
{
    return float(xorshift(state)) * 2.3283064365386963e-10;
}

void swap(inout float a, inout float b)
{
    float temp = a;
    a = b;
    b = temp;
}

vec3 affineTransformPoint(const in vec3 point, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    return vec3(dot(row0.xyz, point) + row0.w,
                dot(row1.xyz, point) + row1.w,
                dot(row2.xyz, point) + row2.w);
}

vec3 affineTransformDirection(const in vec3 direction, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    return vec3(dot(row0.xyz, direction),
                dot(row1.xyz, direction),
                dot(row2.xyz, direction));
}

Ray affineTransformRay(const in Ray ray, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    Ray newRay;
    newRay.color = ray.color;
    newRay.origin = affineTransformPoint(ray.origin, row0, row1, row2); 
    newRay.direction = affineTransformDirection(ray.direction, row0, row1, row2);
    return newRay;
}

vec3 interpNormal(const in vec3 normal0, const in vec3 normal1, const in vec3 normal2, const in float u, const in float v)
{
    float w = 1.0 - u - v;
    vec3 normal = w * normal0 + u * normal1 + v * normal2;
    return normalize(normal);
}


float intersectPlane(const in Ray ray, const in vec3 P0, const in vec3 N)
{
    float denom = dot(ray.direction, N);
    if (denom == 0)
        denom = 1e-8;
    return dot(P0 - ray.origin, N) / denom;
}

vec3 fresnel_Schlick(const in float cosTheta,const in vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float GGX_D(const in float NdotH,const in float alpha)
{
    float a2 = alpha * alpha;
    float d  = NdotH * NdotH * (a2 - 1.0) + 1.0;
    return a2 / (PI * d * d);
}

float GGX_G1(const in float NdotX,const in float alpha)
{
    if (NdotX <= 0.0) return 0.0;
    float a2 = alpha * alpha;
    float NdotX2 = NdotX * NdotX;
    float denom = NdotX + sqrt(a2 + (1.0 - a2) * NdotX2);
    return (2.0 * NdotX) / max(denom, 1e-6);
}

void buildOrthonormalBasis(const in vec3 normal, out vec3 T1, out vec3 T2)
{
    if (abs(normal.z) < 0.999)
        T1 = normalize(cross(normal, vec3(0.0, 0.0, 1.0)));
    else
        T1 = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));

    T2 = cross(normal, T1);
}

vec3 SampleVndf_Hemisphere(const in vec2 rand,const in vec3 incoming_dir)
{
    float phi = 2.0f * M_PI * rand.x;
    float z = fma((1.0f - rand.y), (1.0f + incoming_dir.z), -incoming_dir.z);
    float sinTheta = sqrt(clamp(1.0f - z * z, 0.0f, 1.0f));
    float x = sinTheta * cos(phi);
    float y = sinTheta * sin(phi);
    vec3 c = vec3(x, y, z);
    vec3 h = c + incoming_dir;
    return h;
}

vec3 SampleVndf_GGX(const in vec2 rand, const in vec3 incoming_dir, const in vec2 alpha)
{
    vec3 incoming_dir_std = normalize(vec3(incoming_dir.xy * alpha, incoming_dir.z));
    vec3 wmStd = SampleVndf_Hemisphere(rand, incoming_dir_std);
    vec3 wm = normalize(vec3(wmStd.xy * alpha, wmStd.z));
    return wm;
}

//temp
vec3 hsv2rgb(vec3 c) { // compact HSV->RGB
    vec3 p = abs(fract(c.x + vec3(0,2,4)/6.0)*6.0 - 3.0);
    return c.z * mix(vec3(1.0), clamp(p-1.0,0.0,1.0), c.y);
}
vec3 directionHue(vec3 n) {
    n = normalize(n);
    float az = atan(n.z, n.x);                 // [-pi,pi]
    float el = asin(clamp(n.y, -1.0, 1.0));    // [-pi/2,pi/2]
    float H = (az / (2.0*3.14159265)) + 0.5;   // [0,1]
    float S = 0.7;
    float V = 0.5 + 0.5 * (el/(0.5*3.14159265)); // brighter when pointing up
    return hsv2rgb(vec3(H,S,V));
}

//~~~~~~~~~~~~~ core functions ~~~~~~~~~~~~~



vec4 computeTextureDifferential(const in Ray ray, const in Ray rayDX, const in Ray rayDY, const in float tHit, const in vec3 v0, const in vec3 e1, const in vec3 e2, const in vec2 uv0, const in vec2 uv1, const in vec2 uv2)
{
    //too lazy to explain this here hopefully there is more detail in ReadMe.md lol
    vec3 normal = normalize(cross(e1, e2));
    
    vec3 P = ray.origin + tHit * ray.direction;
    
    float tHitDx = intersectPlane(rayDX, v0, normal);
    float tHitDy = intersectPlane(rayDY, v0, normal);
    
    vec3 Px = rayDX.origin + tHitDx * rayDX.direction;
    vec3 Py = rayDY.origin + tHitDy * rayDY.direction;
   
    vec3 dPdx = Px - P;
    vec3 dPdy = Py - P;
    
    vec2 duv1 = uv1 - uv0;
    vec2 duv2 = uv2 - uv0;
    
    float r = 1.0 / (duv1.x * duv2.y - duv1.y * duv2.x);
    vec3 dPdu = (e1 * duv2.y - e2 * duv1.y) * r;
    vec3 dPdv = (e2 * duv1.x - e1 * duv2.x) * r;

    float a = dot(dPdu, dPdu);
    float b = dot(dPdu, dPdv);
    float c = dot(dPdv, dPdv);

    float det = a * c - b * b;
    if (abs(det) < 1E-8)
        return vec4(0.0, 0.0, 0.0, 0.0);
    float ex = dot(dPdu, dPdx);
    float fx = dot(dPdv, dPdx);

    float dudx = (c * ex - b * fx) / det;
    float dvdx = (-b * ex + a * fx) / det;

    float ey = dot(dPdu, dPdy);
    float fy = dot(dPdv, dPdy);

    float dudy = (c * ey - b * fy) / det;
    float dvdy = (-b * ey + a * fy) / det;

    vec2 dTdx = vec2(dudx, dvdx);
    vec2 dTdy = vec2(dudy, dvdy);

    dTdx.y = -dTdx.y;
    dTdy.y = -dTdy.y;

    return vec4(dTdx, dTdy);
}

Ray generateRay(const in uvec2 pixel)
{
    vec2 UV = (vec2(pixel) + 0.5) / vec2(Params.imageSize);

    vec2 normalisedDeviceCoordinate = UV * 2.0 - 1.0;

    vec4 nearPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 0.0, 1.0);
    vec4 farPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 1.0, 1.0);

    vec3 point0 = nearPoint.xyz / nearPoint.w;
    vec3 point1 = farPoint.xyz / farPoint.w;

    Ray ray;
    ray.origin = Params.camPos_time.xyz;
    ray.direction = normalize(point1 - point0);
    ray.color = vec3(0.0);
    return ray;
}

bool intersectingAABB(const in Ray ray, const in vec3 bbMin, const in vec3 bbMax, const in float tMin, const in float tMax, inout float tEnter, inout float tExit)
{
    //ray forula for point P along the ray at some distance t from origin:
    // P(t) = O + t * D where O is Origin vec3 and D is Normalized vec3 Direction. 
    float t0 = tMin;
    float t1 = tMax;

    for (int axis = 0; axis < 3; axis++)
    {
        float originI = ray.origin[axis];
        float directionI = ray.direction[axis];
        float minBoxA = bbMin[axis];
        float maxBoxA = bbMax[axis];

        if (abs(directionI) <= 1e-8)
        {
            if (originI < minBoxA || originI > maxBoxA)
                return false;

        }
        else
        {
            float inverseDirectionI = 1.0 / directionI;
            float tNearA = (minBoxA - originI) * inverseDirectionI;
            float tFarA = (maxBoxA - originI) * inverseDirectionI;
            if (tNearA > tFarA)
                swap(tNearA, tFarA);
            
            t0 = tNearA > t0 ? tNearA : t0;
            t1 = tFarA < t1 ? tFarA : t1;
            if (t1 < t0)
                return false;
        }
    }
    tEnter = t0;
    tExit = t1;
    return (tExit >= tMin) && (tEnter <= tMax);
}

bool moller_trumbore(const in Ray ray, inout Hit hit, const in vec3 vertex_0, const in vec3 edge_1, const in vec3 edge_2, inout float min_distance)
{
    //algorithm final form:
    /*
       | t |                     | Q . edge2 |
       | u | = 1 / (P . edge1) * |   P . T   |
       | v |                     |   Q . D   |
    */
    //where:
    /*
        D - Nromalized ray direction
        P = D X edge2
        Q = T X edge1
        T = O - vertex0
        O - ray Origin
    */
    vec3 P = cross(ray.direction, edge_2);
    float det = dot(P, edge_1);

    if (abs(det) <= 1e-8)
        return false;
    
    float inverse_det = 1 / det;
    vec3 T = ray.origin - vertex_0;

    float u = dot(T, P) * inverse_det;
    if (u < 0.0 || u > 1.0)
        return false;
    
    vec3 Q = cross(T, edge_1);
    float v = dot(ray.direction, Q) * inverse_det;
    if (v < 0.0 || (v + u) > 1.0)
        return false;
    float t = dot(edge_2, Q) * inverse_det;
    if (t < 1e-4)
        return false;
    if (t < min_distance)
    {
        min_distance = t;
        hit.dist_to_hit = t;
        hit.barrycentricUV.x = u;
        hit.barrycentricUV.y = v;
        return true;
    }
    return false;
}

void traverseTLAS(const in Ray ray, const in uint root, inout uint instancesOut[30], const in float tEnter, const in float tExit, out int outPutPointer)
{
    uint stack[30];
    int stackPointer = 0;
    stack[stackPointer] = root;
    outPutPointer = 0;
        

    while (stackPointer >= 0)
    {
        float tNearLeft, tNearRight, tFarLeft, tFarRight;

        uvec4 meta = tlasNodes[stack[stackPointer]].meta;
        if (meta.y > 0)
        {
            uint instanceI = instanceIndices[meta.x];
            Ray modelRay = affineTransformRay(ray, instances[instanceI].worldToModel0, instances[instanceI].worldToModel1, instances[instanceI].worldToModel2);
            vec3 bbmin = vec3(instances[instanceI].aabbMin);
            vec3 bbmax = vec3(instances[instanceI].aabbMax);
            float tNear, tFar;
            if (intersectingAABB(modelRay, bbmin, bbmax, tEnter, tExit, tNear, tFar))
            {
                vec3 pModel = modelRay.origin + tNear * modelRay.direction;
                vec3 pWorld = affineTransformPoint(pModel,
                                instances[instanceI].modelToWorld0,
                                instances[instanceI].modelToWorld1,
                                instances[instanceI].modelToWorld2);
                float tNearWorld = dot(pWorld - ray.origin, normalize(ray.direction));
                if (outPutPointer < 30)
                {
                    instancesOut[outPutPointer] = instanceI;
                    outPutPointer++;
                }
            }
        
            stackPointer--;
            continue;
        }
        TLASNodeGPU leftNode = tlasNodes[meta.z];
        TLASNodeGPU rightNode = tlasNodes[meta.w];

        vec3 left_bbMin = vec3(leftNode.bbMin);
        vec3 left_bbMax = vec3(leftNode.bbMax);

        vec3 right_bbMin = vec3(rightNode.bbMin);
        vec3 right_bbMax = vec3(rightNode.bbMax);

        bool hitLeft = intersectingAABB(ray, left_bbMin, left_bbMax, tEnter, tExit, tNearLeft, tFarLeft);
        bool hitRight = intersectingAABB(ray, right_bbMin, right_bbMax, tEnter, tExit, tNearRight, tFarRight);

        if (hitLeft && hitRight)
        {
            if (tNearLeft > tNearRight)
            {
                stack[stackPointer] = meta.z;
                stackPointer++;
                stack[stackPointer] = meta.w;
            }
            else
            {
                stack[stackPointer] = meta.w;
                stackPointer++;
                stack[stackPointer] = meta.z;
            }
        }
        else if (hitLeft)
            stack[stackPointer] = meta.z;
        else if (hitRight)
            stack[stackPointer] = meta.w;
        else
            stackPointer--;
    }
}


void traverseBLAS(const in Ray ray, inout Hit hit, const in uint nodeOffset, const in uint triBase, inout float closestT, const in float modelToWorldScale, const in float modelToWorldScaleInverse)
{
    const float ORDER_EPS = 1e-6;

    uint stack[64];
    int  stackPointer = 0;
    stack[stackPointer] = nodeOffset;


    while (stackPointer >= 0)
    {

        float tNearLeft, tNearRight, tFarLeft, tFarRight;

        SBVHNode node = bvhNodes[stack[stackPointer]];

        vec4 left_count_n_max = node.bbMax_left__left_count;
        vec3 left_bbMax       = vec3(left_count_n_max);
        uint left_count       = floatBitsToUint(left_count_n_max.w);

        vec4 left_start_n_min = node.bbMin_left__left_start;
        vec3 left_bbMin       = vec3(left_start_n_min);
        uint left_start       = floatBitsToUint(left_start_n_min.w);

        if (left_count != 0xFFFFFFFFu)
        {
            float tNearLeaf, tFarLeaf;
            bool leafHit = intersectingAABB(ray, left_bbMin, left_bbMax, 1e-6, closestT * modelToWorldScaleInverse, tNearLeaf, tFarLeaf);
            if (!leafHit || tNearLeaf * modelToWorldScale >= closestT)
            {
                stackPointer--;
                continue;
            }

            float min_distance = closestT * modelToWorldScaleInverse;
            uint  primIndex    = 0xFFFFFFFFu;

            for (uint i = 0; i < left_count; i++)
            {
                uint prim = left_start + triBase + i;
                MollerTriangle triangle = triangles[prim];
                if (moller_trumbore(ray, hit,
                                    vec3(triangle.vertex_0),
                                    vec3(triangle.edge_vec1),
                                    vec3(triangle.edge_vec2),
                                    min_distance))
                {
                    primIndex = prim;
                }
            }
            if (primIndex != 0xFFFFFFFFu)
            {
                closestT = min_distance * modelToWorldScale;
                hit.primitiveIndex = primIndex;
            }
            stackPointer--;
            continue;
        }

        vec3 right_bbMax = vec3(node.bbMax_right__right_count);

        vec4 right_start_n_Min = node.bbMin_right__right_start;
        vec3 right_bbMin       = vec3(right_start_n_Min);
        uint right_start       = floatBitsToUint(right_start_n_Min.w);


        bool hitLeft  = intersectingAABB(ray, left_bbMin,  left_bbMax,  1e-6, closestT * modelToWorldScaleInverse, tNearLeft,  tFarLeft);
        bool hitRight = intersectingAABB(ray, right_bbMin, right_bbMax, 1e-6, closestT * modelToWorldScaleInverse, tNearRight, tFarRight);

        if ( (!hitLeft  || tNearLeft  * modelToWorldScale >= closestT) &&
             (!hitRight || tNearRight * modelToWorldScale >= closestT) )
        {
            stackPointer--;
            continue;
        }

        if (hitLeft && hitRight)
        {
            bool leftIsNear = (abs(tNearLeft - tNearRight) > ORDER_EPS) ? (tNearLeft < tNearRight) : (left_start < right_start);

            uint nearIdx = leftIsNear ? (left_start  + nodeOffset) : (right_start + nodeOffset);
            uint farIdx  = leftIsNear ? (right_start + nodeOffset) : (left_start  + nodeOffset);

            stack[stackPointer] = farIdx;
            stackPointer++;
            stack[stackPointer] = nearIdx;
        }
        else if (hitLeft)
        {
            stack[stackPointer] = left_start + nodeOffset;
        }
        else
        {
            stack[stackPointer] = right_start + nodeOffset;
        }
    }
}

vec4 getTextureSample(const in uint textureIndex, inout Hit hit, const in vec2 vt0, const in vec2 vt1, const in vec2 vt2, const in Ray ray, const in uvec2 pixel)
{
    vec2 UV = (1.0 - hit.barrycentricUV.x - hit.barrycentricUV.y) * vt0 + hit.barrycentricUV.x * vt1 + hit.barrycentricUV.y * vt2;
    UV.y = 1.0 - UV.y;


    Ray rayDX = generateRay(pixel + uvec2(1, 0));
    Ray rayDY = generateRay(pixel + uvec2(0, 1));

    Ray modelRay = affineTransformRay(ray, instances[hit.instanceIndex].worldToModel0, instances[hit.instanceIndex].worldToModel1, instances[hit.instanceIndex].worldToModel2);
    rayDX = affineTransformRay(rayDX, instances[hit.instanceIndex].worldToModel0, instances[hit.instanceIndex].worldToModel1, instances[hit.instanceIndex].worldToModel2);
    rayDY = affineTransformRay(rayDY, instances[hit.instanceIndex].worldToModel0, instances[hit.instanceIndex].worldToModel1, instances[hit.instanceIndex].worldToModel2);

    
    MollerTriangle trinagle = triangles[hit.primitiveIndex];

    
    vec4 textureDifferential = computeTextureDifferential(modelRay, rayDX, rayDY, hit.dist_to_hit,
                                                vec3(trinagle.vertex_0), vec3(trinagle.edge_vec1), vec3(trinagle.edge_vec2),
                                                vt0, vt1, vt2);

    return textureGrad(textures2D[nonuniformEXT(textureIndex)], UV, vec2(textureDifferential.xy), vec2(textureDifferential.zw));
}

void trace(const in Ray ray, inout Hit hit)
{
    uint rootId = Params.rootIndex;
    uint TLASInstanceLeafIDs[30];
    float tEnter, tExit;
    if (intersectingAABB(ray, vec3(tlasNodes[rootId].bbMin), vec3(tlasNodes[rootId].bbMax), 1e-8, 1e30, tEnter, tExit))
    {

        int leafCount = 0;
        traverseTLAS(ray, rootId, TLASInstanceLeafIDs, tEnter, tExit, leafCount);
        float closestT = 1e30;
        for (int i = 0; i < leafCount; i++)
        {
            uint instanceId = TLASInstanceLeafIDs[i];
            Ray modelRay = affineTransformRay(ray, instances[instanceId].worldToModel0, instances[instanceId].worldToModel1, instances[instanceId].worldToModel2);
            vec3 worldDir = affineTransformDirection(modelRay.direction, instances[instanceId].modelToWorld0, instances[instanceId].modelToWorld1, instances[instanceId].modelToWorld2);
            float modelToWorldScale = length(worldDir);
            float modelToWorldScaleInverse = 1.0 / modelToWorldScale;
            float previousClosestT = closestT;
        
            traverseBLAS(modelRay, hit,
                instances[instanceId].bases01.x,
                instances[instanceId].bases01.y,
                closestT, modelToWorldScale, modelToWorldScaleInverse
            );

            if (hit.primitiveIndex != 0xFFFFFFFFu && closestT < previousClosestT)
            {
                hit.instanceIndex = instanceId;
                hit.world_dist_to_hit = closestT
            }
        }
    }

}



float getGGXPDF(const in vec3 normal, const in vec3 outgoing_dir, const in float roughness, const in vec3 candidate_wi)
{
    float Ndotw_o = dot(normal, outgoing_dir);
    float Ndotw_i = dot(normal, candidate_wi);
    if (Ndotw_o <= 0.0 || Ndotw_i <= 0.0)
        return 0.0;

    vec3 H = normalize(candidate_wi + outgoing_dir);
    float NdotH = max(dot(normal, H), 0.0);
    float w_odotH = max(dot(wo, H), 0.0);

    float alpha = roughness * roughness;

    float D   = GGX_D(NdotH, alpha);
    float G1v = GGX_G1(Ndotw_o, alpha);

    float pdf_h = (D * G1v * w_odotH) / Ndotw_o;

    float pdf_wi = pdf_h / max(4.0 * w_odotH, 1e-6);

    return pdf_wi;
}

void sampleGGX(const in vec3 normal,const in vec3 outgoing_dir, const int float roughness, const in float rand1, const in float rand2, out vec3 incoming_dir, out float PDF)
{
    PDF = 0.0;

    float NdotV = dot(normal, outgoing_dir);
    if (NdotV <= 0.0)
        return;

    vec3 T, T2;
    buildOrthonormalBasis(normal, T, T2);

    vec3 Vlocal = vec3(dot(outgoing_dir, T), dot(outgoing_dir, T2), dot(outgoing_dir, normal));

    float alpha = roughness * roughness;

    vec3 hLocal = SampleVndf_GGX(vec2(rand1, rand2), normalize(Vlocal), vec2(alpha, alpha));
    hLocal = normalize(hLocal);

    vec3 incoming_local = reflect(-Vlocal, hLocal);
    if (incoming_local.z <= 0.0)
        return;

    vec3 H = normalize(hLocal.x * T + hLocal.y * T2 + hLocal.z * normal);

    incoming_dir = normalize(incoming_local.x * T + incoming_local.y * T2 + incoming_local.z * normal);

    PDF = getGGXPDF(normal, outgoing_dir, roughness, incoming_dir);
}

float getDiffusePDF(const in vec3 normal, const in vec3 candidate_wi)
{
    float cosine = dot(normal, candidate_wi);
    return (cosine > 0.0) ? (cosine / PI) : 0.0;
}

void sampleDiffuse(const in vec3 normal,const in float rand1, const in float rand2 ,out vec3 incoming_dir, out float PDF)
{
    PDF = 0.0;

    float phi = 2.0 * PI * rand1;
    float r   = sqrt(rand2);
    float x   = r * cos(phi);
    float y   = r * sin(phi);
    float z   = sqrt(1.0 - rand2);

    vec3 local_direction = vec3(x, y, z)

    vec3 T1, T2;
    buildOrthonormalBasis(normal, T1, T2);

    incoming_dir = normalize(localDir.x * T + localDir.y * T2 + localDir.z * normal);

    PDF = getDiffusePDF(normal, w_i);
}

vec3 evaluateBRDF(const in vec3 normal, const in vec3 incoming_dir)
{
    // we need the f value. its f of diffuse + f of specular. 

    //we calculate f of difuse simple lambertian term
    vec3 f_diffuse = vec3(0.0);

    //we now calculate f of specular GGX
    vec3 f_specular = vec3(0.1);

    //thats it
    return f_diffuse + f_specular;
}

void BRDF(const in vec3 normal, const in vec3 outgoing_dir,
          const in vec3 baseColor, const in vec3 F0, const in float roughness,
          const in float randLobe, const in float rand1, const in float rand2,
          out vec3 incoming_dir, out vec3 BRDF_value, out float BRDF_PDF)
{
    incoming_dir = vec3(0.0);
    BRDF_value = vec3(0.0);
    BRDF_PDF = 0.0;

    // make sure normal and outgoing direction are on the same side.
    float cosineTheta = dot(normal, outgoing_dir);
    if (cosineTheta <= 0.0)
        return;

    // pick 2 weights such that they add to 1 to pick from diffuse or GGX
    vec3 Fview = fresnel_Schlick(cosineTheta, F0);
    float specular_weight = clamp(max(max(Fview.r, Fview.g), Fview.b), 0.0, 0.98);
    float diffuse_weight = 1.0 - specular_weight;

    vec3 candidate_wi = vec3(0.0);
    float s_pdf = 0.0;
    float d_pdf = 0.0;
    if (randLobe < specular_weight)
    {
        //if we are sampling specular (GGX):
        sampleGGX(normal, candidate_wi, s_pdf);
        d_pdf = getDiffusePDF(normal,candidate_wi);
    }
    else
    {
        //if we are sampling diffuse (Lambert):
        sampleDiffuse(normal,rand1, rand2, candidate_wi, d_pdf);
        s_pdf = getGGXPDF(candidate_wi);
    }

    //now we can combine the PDF's with the weights used to pick sampling strategy.
    float pdf = specular_weight * s_pdf + diffuse_weight * d_pdf;

    //after some final gates we can assign the out values. for BRDF value we will call the evaluating function
    if (pdf <= 0.0)
        return;
    incoming_dir = candidate_wi;
    BRDF_value = evaluateBRDF(normal, candidate_wi);
    PDF = pdf;
}

void BSDF(const in vec3 normal, const in vec3 outgoing_dir, inout uint rngState,
          const in vec3 baseColor, const in vec3 F0, const in float roughness, const in vec3 emission,
          out vec3 incoming_dir, out vec3 BSDF_value, out float BSDF_PDF)
{
    incoming_dir = vec3(0.0);
    BSDF_value = vec3(0.0);
    BSDF_PDF = 0.0;

    // generate some random values to be used
    float randLobe = rand(rngState);
    float rand1 = rand(rngState);
    float rand2 = rand(rngState);
    // in the future add BTDF branch
    vec3 w_i_BRDF;
    vec3 BRDF_value;
    float BRDF_PDF;

    // this will need the material data and random values
    BRDF(normal, w_i_BRDF, BRDF_value, BRDF_PDF);
    
    if (BRDF_PDF <= 0.0)
        return;
    
    incoming_dir = w_i_BRDF;
    BSDF_value = BRDF_value;
    BSDF_PDF = BRDF_PDF;
}

vec3 solveRenderingEquationForHit(inout Ray ray, inout Hit hit, inout vec3 throughput, inout uint rngState)
{
    vec3 luminance = vec3(0.0);
    if (hit.instanceIndex != 0xFFFFFFFFu && hit.primitiveIndex != 0xFFFFFFFFu)
    {
        //get material for this hit.
        uint materialIndex = floatBitsToUint(texture_material.w);
        materialIndex += instances[hit.instanceIndex].bases01.w;
        MaterialGPU material = materials[materialIndex];
        uint textureIndex = floatBitsToUint(material.textureId.x);

        //shading trinagle for normal data
        ShadingTriangle trinagle = shadingTris[hit.primitiveIndex];
        vec4 vertex0_data = trinagle.vertexNormal0_uv;
        vec4 vertex1_data = trinagle.vertexNormal1_uv;
        vec4 vertex2_data = trinagle.vertexNormal2_uv;

        //grab the intended base color
        vec3 baseColor = material.baseColor_opacity.xyz;
        if (textureIndex != 0xFFFFFFFFu)
        {
            vec4 texture_material = trinagle.texture_materialId;

            vec2 vt0 = vec2(vertex0_data.w, texture_material.x);
            vec2 vt1 = vec2(vertex1_data.w, texture_material.y);
            vec2 vt2 = vec2(vertex2_data.w, texture_material.z);
            
            vec3 baseColor = vec3(getTextureSample(textureIndex, hit, vt0, vt1, vt2, ray, pixel));
        }

        // interpolate the normal and convert it to world space;
        vec3 normal = interpNormal(vertex0_data.xyz, vertex1_data.xyz, vertex2_data.xyz, hit.barrycentricUV.x, hit.barrycentricUV.y);
        bool frontFace = dot(normal, -ray.direction) > 0.0;
        normal = frontFace ? normal : -normal;
        //this needs to be swaped for inverse transpose of linnear part of the model->world matrix that needs to be calculated per instance on the cpu
        normal = affineTransformDirection(normal, instances[hit.instanceIndex].modelToWorld0, instances[hit.instanceIndex].modelToWorld1, instances[hit.instanceIndex].modelToWorld2);

        //get luminacne for this hit.
        luminance += throughput * material.emission_flags.xyz;
        //get hit point in world space
        vec3 hitPoint = ray.origin + hit.world_dist_to_hit * ray.direction;

        //sample BSDF
        vec3 f_BSDF;
        float pdf_wi;
        BSDF(normal, -ray.direction, rngState, 
             baseColor, material.F0_ior_rough.xyz, material.F0_ior_rough.w, material.emission_flags.xyz,
             ray.direction, f_BSDF, pdf_wi);
        
        //finalise the new ray
        ray.origin = hitPoint + 1e-6 * ray.direction;

        //update the throughput
        float cosineTheta = dot(normal. ray.direction);
        if (pdf > 0.0 && cosineTheta > 0.0)
            throughput *= f_BSDF * (cosineTheta / pdf_wi);
    }
    return luminance;
}



// ~~~~~~~~~~~~~ main ~~~~~~~~~~~~~

void main()
{
    //early pixel gate && get pixel XY.
    uvec2 pixel = gl_GlobalInvocationID.xy;
    if (pixel.x >= Params.imageSize.x || pixel.y >= Params.imageSize.y)
        return;

    bool instanceSelected = (Params.flags & FLAG_INSTANCE_SEL) != 0u;
    uint selectedIdx      = Params.flags & MASK_INSTANCE_IDX;
    bool bPressedFlag     = (Params.flags & FLAG_B) != 0u;
    
    uint  bInterpRaw      = (Params.flags & B_INTERP_MASK) >> B_INTERP_SHIFT;
    bool  bTransitionPlaying = (bInterpRaw != 0u);
    float bInterp         = float(bInterpRaw) / float(0x3FFu);
    uint rngState = wang_hash(pixel ^ (floatBitsToUint(Params.camPos_time.w) * 1664525u));
    
    

    //make the main ray.
    Ray ray = generateRay(pixel);
    //if we hit the root TLAS node i.e ANYTHING in the scene do the work, otherwise we missed everything

    float terminate = 0.0;
    Hit hit = Hit(1e30, 1e30, 0xFFFFFFFFu, 0xFFFFFFFFu, vec2(0.0));
    //main work loop.
    vec3 throughput = vec3(1.0);
    while (true)
    {
        trace(ray, hit);

        solveRenderingEquationForHit(ray, hit, throughput, rngState);
        

        if (instanceSelected && hit.instanceIndex == selectedIdx)
            ray.color = mix(ray.color, vec3(1.0, 1.0, 0.0), 0.4);
        // update Ray origin and direction based on 
        if (terminate < 1.0)
            break;
        else
            break;
    }

       
    imageStore(outImage, ivec2(pixel), vec4(ray.color, 1.0));
}
