#version 460
#extension GL_EXT_nonuniform_qualifier : enable
// ------ Cpu side passed Objects -------
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D outImage;

struct SBVHNode {
    vec4 bbMin_left__left_start;
    vec4 bbMax_left__left_count;
    vec4 bbMin_right__right_start;
    vec4 bbMax_right__right_count;
};

struct MollerTriangle {
    vec4 vertex_0;
    vec4 edge_vec1;
    vec4 edge_vec2;
};

struct ShadingTriangle {
    vec4 vertexNormal0_uv;
    vec4 vertexNormal1_uv;
    vec4 vertexNormal2_uv;
    vec4 texture_materialId;
};

struct MaterialGPU {
    vec4 baseColor_opacity;
    vec4 F0_ior_rough;
    vec4 emission_flags;
    vec4 textureId;
};

layout(set = 0, binding = 1, std430) readonly buffer BVHNodesBuf { SBVHNode        bvhNodes[]; };
layout(set = 0, binding = 2, std430) readonly buffer MollerBuf   { MollerTriangle  triangles[]; };
layout(set = 0, binding = 3, std430) readonly buffer ShadeBuf    { ShadingTriangle shadingTris[]; };
layout(set = 0, binding = 4, std430) readonly buffer MtlBuf      { MaterialGPU     materials[];  };

layout(set = 0, binding = 5, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;
    uint  flags;
} Params;

struct TLASNodeGPU {
    vec4  bbMin;           
    vec4  bbMax;          
    uvec4 meta;            // x=first, y=count, z=left, w=right
};

struct InstanceDataGPU {
    vec4 modelToWorld0;
    vec4 modelToWorld1;
    vec4 modelToWorld2;

    vec4 worldToModel0;
    vec4 worldToModel1;
    vec4 worldToModel2;

    vec4 aabbMin;
    vec4 aabbMax;

    uvec4 bases01; // x=nodeBase, y=triBase, z=shadeTriBase, w=materialBase
    uvec4 bases23; // x=textureBase, y=sbvhRoot, w=triLightOffset
};

struct EmisiveTrinagle {
    uint primitiveIndex;
    uint instanceIndex;
    uint materialIndex;
    uint padding;
};

layout(set = 0, binding = 6, std430) readonly buffer TLASNodesBuf { TLASNodeGPU      tlasNodes[];   };
layout(set = 0, binding = 7, std430) readonly buffer InstanceBuf  { InstanceDataGPU  instances[];   };
layout(set = 0, binding = 8, std430) readonly buffer InstIdxBuf { uint instanceIndices[]; };
layout(set = 0, binding = 9) uniform sampler2D textures2D[];
layout(set = 0, binding = 10, std430) readonly buffer EmissiveTriBuf {EmisiveTrinagle emissiveTrinagles[]; };
layout(set = 0, binding = 11, std430) readonly buffer LightProb { float lightProbability[]; };
layout(set = 0, binding = 12, std430) readonly buffer LightPdf { float lightPDF[]; };
layout(set = 0, binding = 13, std430) readonly buffer LightAli { uint LightAlias[]; };
layout(set = 0, binding = 14, std430) readonly buffer triToLightIdxBuffer { uint triToLightIdx[]; };

// ---------- RayTracing Engine ----------


//~~~~~~~~~~~~~ comp specific data structs & constants ~~~~~~~~~~~~~
struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Hit {
    float dist_to_hit;
    float world_dist_to_hit;
    uint instanceIndex;
    uint primitiveIndex;
    vec2 barrycentricUV;
};

const uint FLAG_B            = 1u << 31;
const uint FLAG_INSTANCE_SEL = 1u << 30;
const uint B_INTERP_SHIFT    = 20u;
const uint B_INTERP_MASK     = 0x3FFu << B_INTERP_SHIFT;
const uint MASK_INSTANCE_IDX = 0xFu;
const float PI      = 3.14159265358979323846;
const float INV_PI  = 0.31830988618379067154;


//~~~~~~~~~~~~~ helpers ~~~~~~~~~~~~~

uint wang_hash(uint s)
{
    s = (s ^ 61u) ^ (s >> 16);
    s *= 9u;
    s = s ^ (s >> 4);
    s *= 0x27d4eb2du;
    s = s ^ (s >> 15);
    return s;
}

uint xorshift(inout uint state)
{
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    return state;
}

float floatConstruct(uint state)
{
    const uint ieeeMantissa = 0x007FFFFFu;
    const uint ieeeOne      = 0x3F800000u;

    state &= ieeeMantissa;
    state |= ieeeOne;

    float  f = uintBitsToFloat(state);
    return f - 1.0;
}

float rand(inout uint state)
{
    return floatConstruct(wang_hash(xorshift(state)));
}

bool badFloat(float x)
{
    return isnan(x) || isinf(x) || x < 0.0;
}


void swap(inout float a, inout float b)
{
    float temp = a;
    a = b;
    b = temp;
}

float safeSqrt(float x) {
    return sqrt(max(x, 0.0));
}

float angleBetween(vec3 a, vec3 b) {
    return acos(clamp(dot(a, b), -1.0, 1.0));
}

vec3 gramSchmidt(vec3 v, vec3 n) {
    return normalize(v - n * dot(v, n));
}

float differenceOfProducts(float a, float b, float c, float d) {
    return a * b - c * d;
}

float sumOfProducts(float a, float b, float c, float d) {
    return a * b + c * d;
}


vec3 affineTransformPoint(const in vec3 point, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    return vec3(dot(row0.xyz, point) + row0.w,
                dot(row1.xyz, point) + row1.w,
                dot(row2.xyz, point) + row2.w);
}

vec3 affineTransformDirection(const in vec3 direction, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    return vec3(dot(row0.xyz, direction),
                dot(row1.xyz, direction),
                dot(row2.xyz, direction));
}

Ray affineTransformRay(const in Ray ray, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    Ray newRay;
    newRay.origin = affineTransformPoint(ray.origin, row0, row1, row2); 
    newRay.direction = affineTransformDirection(ray.direction, row0, row1, row2);
    return newRay;
}

vec3 interpNormal(const in vec3 normal0, const in vec3 normal1, const in vec3 normal2, const in float u, const in float v)
{
    float w = 1.0 - u - v;
    vec3 normal = w * normal0 + u * normal1 + v * normal2;
    return normalize(normal);
}


float intersectPlane(const in Ray ray, const in vec3 P0, const in vec3 N)
{
    float denom = dot(ray.direction, N);
    if (denom == 0)
        denom = 1e-8;
    return dot(P0 - ray.origin, N) / denom;
}

vec3 fresnel_Schlick(const in float cosTheta, const in vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float GGX_D(const in float NdotH,const in float alpha)
{
    float a2 = alpha * alpha;
    float d  = NdotH * NdotH * (a2 - 1.0) + 1.0;
    return a2 / (PI * d * d);
}

float GGX_G1(const in float NdotX,const in float alpha)
{
    if (NdotX <= 0.0) return 0.0;
    float a2 = alpha * alpha;
    float NdotX2 = NdotX * NdotX;
    float denom = NdotX + sqrt(a2 + (1.0 - a2) * NdotX2);
    return (2.0 * NdotX) / max(denom, 1e-6);
}

void buildOrthonormalBasis(const in vec3 normal, out vec3 T1, out vec3 T2)
{
    if (abs(normal.z) < 0.999)
        T1 = normalize(cross(normal, vec3(0.0, 0.0, 1.0)));
    else
        T1 = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));

    T2 = cross(normal, T1);
}

vec3 SampleVndf_Hemisphere(const in vec2 rand,const in vec3 incoming_dir)
{
    float phi = 2.0f * PI * rand.x;
    float z = fma((1.0f - rand.y), (1.0f + incoming_dir.z), -incoming_dir.z);
    float sinTheta = sqrt(clamp(1.0f - z * z, 0.0f, 1.0f));
    float x = sinTheta * cos(phi);
    float y = sinTheta * sin(phi);
    vec3 c = vec3(x, y, z);
    vec3 h = c + incoming_dir;
    return h;
}

vec3 SampleVndf_GGX(const in vec2 rand, const in vec3 incoming_dir, const in vec2 alpha)
{
    vec3 incoming_dir_std = normalize(vec3(incoming_dir.xy * alpha, incoming_dir.z));
    vec3 wmStd = SampleVndf_Hemisphere(rand, incoming_dir_std);
    vec3 wm = normalize(vec3(wmStd.xy * alpha, wmStd.z));
    return wm;
}

uint getLightIndexFromHit(const in uint instanceIndex, const in uint primitiveIndex)
{
    uint localIdx = primitiveIndex - instances[instanceIndex].bases01.z;
    return triToLightIdx[instances[instanceIndex].bases23.w + localIdx];
}

//temp
vec3 hsv2rgb(vec3 c) {
    vec3 p = abs(fract(c.x + vec3(0,2,4)/6.0)*6.0 - 3.0);
    return c.z * mix(vec3(1.0), clamp(p-1.0,0.0,1.0), c.y);
}
vec3 directionHue(vec3 n) {
    n = normalize(n);
    float az = atan(n.z, n.x);
    float el = asin(clamp(n.y, -1.0, 1.0));
    float H = (az / (2.0*3.14159265)) + 0.5;
    float S = 0.7;
    float V = 0.5 + 0.5 * (el/(0.5*3.14159265));
    return hsv2rgb(vec3(H,S,V));
}

//~~~~~~~~~~~~~ core functions ~~~~~~~~~~~~~

vec4 computeTextureDifferential(const in Ray ray, const in Ray rayDX, const in Ray rayDY, const in float tHit, const in vec3 v0, const in vec3 e1, const in vec3 e2, const in vec2 uv0, const in vec2 uv1, const in vec2 uv2)
{
    //too lazy to explain this here hopefully there is more detail in ReadMe.md lol
    vec3 normal = normalize(cross(e1, e2));
    
    vec3 P = ray.origin + tHit * ray.direction;
    
    float tHitDx = intersectPlane(rayDX, v0, normal);
    float tHitDy = intersectPlane(rayDY, v0, normal);
    
    vec3 Px = rayDX.origin + tHitDx * rayDX.direction;
    vec3 Py = rayDY.origin + tHitDy * rayDY.direction;
   
    vec3 dPdx = Px - P;
    vec3 dPdy = Py - P;
    
    vec2 duv1 = uv1 - uv0;
    vec2 duv2 = uv2 - uv0;
    
    float r = 1.0 / (duv1.x * duv2.y - duv1.y * duv2.x);
    vec3 dPdu = (e1 * duv2.y - e2 * duv1.y) * r;
    vec3 dPdv = (e2 * duv1.x - e1 * duv2.x) * r;

    float a = dot(dPdu, dPdu);
    float b = dot(dPdu, dPdv);
    float c = dot(dPdv, dPdv);

    float det = a * c - b * b;
    if (abs(det) < 1E-8)
        return vec4(0.0, 0.0, 0.0, 0.0);
    float ex = dot(dPdu, dPdx);
    float fx = dot(dPdv, dPdx);

    float dudx = (c * ex - b * fx) / det;
    float dvdx = (-b * ex + a * fx) / det;

    float ey = dot(dPdu, dPdy);
    float fy = dot(dPdv, dPdy);

    float dudy = (c * ey - b * fy) / det;
    float dvdy = (-b * ey + a * fy) / det;

    vec2 dTdx = vec2(dudx, dvdx);
    vec2 dTdy = vec2(dudy, dvdy);

    dTdx.y = -dTdx.y;
    dTdy.y = -dTdy.y;

    return vec4(dTdx, dTdy);
}

Ray generateRay(const in uvec2 pixel)
{
    vec2 UV = (vec2(pixel) + 0.5) / vec2(Params.imageSize);

    vec2 normalisedDeviceCoordinate = UV * 2.0 - 1.0;

    vec4 nearPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 0.0, 1.0);
    vec4 farPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 1.0, 1.0);

    vec3 point0 = nearPoint.xyz / nearPoint.w;
    vec3 point1 = farPoint.xyz / farPoint.w;

    Ray ray;
    ray.origin = Params.camPos_time.xyz;
    ray.direction = normalize(point1 - point0);
    return ray;
}

Ray generateRayJittered(uvec2 pixel, vec2 jitter)
{
    vec2 pixelSample = vec2(pixel) + jitter;

    vec2 UV = pixelSample / vec2(Params.imageSize);
    vec2 normalisedDeviceCoordinate = UV * 2.0 - 1.0;

    vec4 nearPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 0.0, 1.0);
    vec4 farPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 1.0, 1.0);

    vec3 point0 = nearPoint.xyz / nearPoint.w;
    vec3 point1 = farPoint.xyz / farPoint.w;

    Ray ray;
    ray.origin = Params.camPos_time.xyz;
    ray.direction = normalize(point1 - point0);
    return ray;
}

bool intersectingAABB(const in Ray ray, const in vec3 bbMin, const in vec3 bbMax, const in float tMin, const in float tMax, inout float tEnter, inout float tExit)
{
    //ray forula for point P along the ray at some distance t from origin:
    // P(t) = O + t * D where O is Origin vec3 and D is Normalized vec3 Direction. 
    float t0 = tMin;
    float t1 = tMax;

    for (int axis = 0; axis < 3; axis++)
    {
        float originI = ray.origin[axis];
        float directionI = ray.direction[axis];
        float minBoxA = bbMin[axis];
        float maxBoxA = bbMax[axis];

        if (abs(directionI) <= 1e-8)
        {
            if (originI < minBoxA || originI > maxBoxA)
                return false;

        }
        else
        {
            float inverseDirectionI = 1.0 / directionI;
            float tNearA = (minBoxA - originI) * inverseDirectionI;
            float tFarA = (maxBoxA - originI) * inverseDirectionI;
            if (tNearA > tFarA)
                swap(tNearA, tFarA);
            
            t0 = tNearA > t0 ? tNearA : t0;
            t1 = tFarA < t1 ? tFarA : t1;
            if (t1 < t0)
                return false;
        }
    }
    tEnter = t0;
    tExit = t1;
    return (tExit >= tMin) && (tEnter <= tMax);
}

bool moller_trumbore(const in Ray ray, inout Hit hit, const in vec3 vertex_0, const in vec3 edge_1, const in vec3 edge_2, inout float min_distance)
{
    //algorithm final form:
    /*
       | t |                     | Q . edge2 |
       | u | = 1 / (P . edge1) * |   P . T   |
       | v |                     |   Q . D   |
    */
    //where:
    /*
        D - Nromalized ray direction
        P = D X edge2
        Q = T X edge1
        T = O - vertex0
        O - ray Origin
    */
    vec3 P = cross(ray.direction, edge_2);
    float det = dot(P, edge_1);

    if (abs(det) <= 1e-8)
        return false;
    
    float inverse_det = 1 / det;
    vec3 T = ray.origin - vertex_0;

    float u = dot(T, P) * inverse_det;
    if (u < 0.0 || u > 1.0)
        return false;
    
    vec3 Q = cross(T, edge_1);
    float v = dot(ray.direction, Q) * inverse_det;
    if (v < 0.0 || (v + u) > 1.0)
        return false;
    float t = dot(edge_2, Q) * inverse_det;
    if (t < 1e-4)
        return false;
    if (t < min_distance)
    {
        min_distance = t;
        hit.dist_to_hit = t;
        hit.barrycentricUV.x = u;
        hit.barrycentricUV.y = v;
        return true;
    }
    return false;
}

void traverseTLAS(const in Ray ray, const in uint root, inout uint instancesOut[30], const in float tEnter, const in float tExit, out int outPutPointer)
{
    uint stack[30];
    int stackPointer = 0;
    stack[stackPointer] = root;
    outPutPointer = 0;
        

    while (stackPointer >= 0)
    {
        float tNearLeft, tNearRight, tFarLeft, tFarRight;

        uvec4 meta = tlasNodes[stack[stackPointer]].meta;
        if (meta.y > 0)
        {
            uint instanceI = instanceIndices[meta.x];
            Ray modelRay = affineTransformRay(ray, instances[instanceI].worldToModel0, instances[instanceI].worldToModel1, instances[instanceI].worldToModel2);
            vec3 bbmin = vec3(instances[instanceI].aabbMin);
            vec3 bbmax = vec3(instances[instanceI].aabbMax);
            float tNear, tFar;
            if (intersectingAABB(modelRay, bbmin, bbmax, tEnter, tExit, tNear, tFar))
            {
                vec3 pModel = modelRay.origin + tNear * modelRay.direction;
                vec3 pWorld = affineTransformPoint(pModel,
                                instances[instanceI].modelToWorld0,
                                instances[instanceI].modelToWorld1,
                                instances[instanceI].modelToWorld2);
                float tNearWorld = dot(pWorld - ray.origin, normalize(ray.direction));
                if (outPutPointer < 30)
                {
                    instancesOut[outPutPointer] = instanceI;
                    outPutPointer++;
                }
            }
        
            stackPointer--;
            continue;
        }
        TLASNodeGPU leftNode = tlasNodes[meta.z];
        TLASNodeGPU rightNode = tlasNodes[meta.w];

        vec3 left_bbMin = vec3(leftNode.bbMin);
        vec3 left_bbMax = vec3(leftNode.bbMax);

        vec3 right_bbMin = vec3(rightNode.bbMin);
        vec3 right_bbMax = vec3(rightNode.bbMax);

        bool hitLeft = intersectingAABB(ray, left_bbMin, left_bbMax, tEnter, tExit, tNearLeft, tFarLeft);
        bool hitRight = intersectingAABB(ray, right_bbMin, right_bbMax, tEnter, tExit, tNearRight, tFarRight);

        if (hitLeft && hitRight)
        {
            if (tNearLeft > tNearRight)
            {
                stack[stackPointer] = meta.z;
                stackPointer++;
                stack[stackPointer] = meta.w;
            }
            else
            {
                stack[stackPointer] = meta.w;
                stackPointer++;
                stack[stackPointer] = meta.z;
            }
        }
        else if (hitLeft)
            stack[stackPointer] = meta.z;
        else if (hitRight)
            stack[stackPointer] = meta.w;
        else
            stackPointer--;
    }
}


void traverseBLAS(const in Ray ray, inout Hit hit, const in uint nodeOffset, const in uint triBase, inout float closestT, const in float modelToWorldScale, const in float modelToWorldScaleInverse)
{
    const float ORDER_EPS = 1e-6;

    uint stack[64];
    int  stackPointer = 0;
    stack[stackPointer] = nodeOffset;


    while (stackPointer >= 0)
    {

        float tNearLeft, tNearRight, tFarLeft, tFarRight;

        SBVHNode node = bvhNodes[stack[stackPointer]];

        vec4 left_count_n_max = node.bbMax_left__left_count;
        vec3 left_bbMax       = vec3(left_count_n_max);
        uint left_count       = floatBitsToUint(left_count_n_max.w);

        vec4 left_start_n_min = node.bbMin_left__left_start;
        vec3 left_bbMin       = vec3(left_start_n_min);
        uint left_start       = floatBitsToUint(left_start_n_min.w);

        if (left_count != 0xFFFFFFFFu)
        {
            float tNearLeaf, tFarLeaf;
            bool leafHit = intersectingAABB(ray, left_bbMin, left_bbMax, 1e-6, closestT * modelToWorldScaleInverse, tNearLeaf, tFarLeaf);
            if (!leafHit || tNearLeaf * modelToWorldScale >= closestT)
            {
                stackPointer--;
                continue;
            }

            float min_distance = closestT * modelToWorldScaleInverse;
            uint  primIndex    = 0xFFFFFFFFu;

            for (uint i = 0; i < left_count; i++)
            {
                uint prim = left_start + triBase + i;
                MollerTriangle triangle = triangles[prim];
                if (moller_trumbore(ray, hit,
                                    vec3(triangle.vertex_0),
                                    vec3(triangle.edge_vec1),
                                    vec3(triangle.edge_vec2),
                                    min_distance))
                {
                    primIndex = prim;
                }
            }
            if (primIndex != 0xFFFFFFFFu)
            {
                closestT = min_distance * modelToWorldScale;
                hit.primitiveIndex = primIndex;
            }
            stackPointer--;
            continue;
        }

        vec3 right_bbMax = vec3(node.bbMax_right__right_count);

        vec4 right_start_n_Min = node.bbMin_right__right_start;
        vec3 right_bbMin       = vec3(right_start_n_Min);
        uint right_start       = floatBitsToUint(right_start_n_Min.w);


        bool hitLeft  = intersectingAABB(ray, left_bbMin,  left_bbMax,  1e-6, closestT * modelToWorldScaleInverse, tNearLeft,  tFarLeft);
        bool hitRight = intersectingAABB(ray, right_bbMin, right_bbMax, 1e-6, closestT * modelToWorldScaleInverse, tNearRight, tFarRight);

        if ( (!hitLeft  || tNearLeft  * modelToWorldScale >= closestT) &&
             (!hitRight || tNearRight * modelToWorldScale >= closestT) )
        {
            stackPointer--;
            continue;
        }

        if (hitLeft && hitRight)
        {
            bool leftIsNear = (abs(tNearLeft - tNearRight) > ORDER_EPS) ? (tNearLeft < tNearRight) : (left_start < right_start);

            uint nearIdx = leftIsNear ? (left_start  + nodeOffset) : (right_start + nodeOffset);
            uint farIdx  = leftIsNear ? (right_start + nodeOffset) : (left_start  + nodeOffset);

            stack[stackPointer] = farIdx;
            stackPointer++;
            stack[stackPointer] = nearIdx;
        }
        else if (hitLeft)
        {
            stack[stackPointer] = left_start + nodeOffset;
        }
        else
        {
            stack[stackPointer] = right_start + nodeOffset;
        }
    }
}

vec4 getTextureSample(const in uint textureIndex, inout Hit hit, const in vec2 vt0, const in vec2 vt1, const in vec2 vt2, const in Ray ray, const in uvec2 pixel)
{
    vec2 UV = (1.0 - hit.barrycentricUV.x - hit.barrycentricUV.y) * vt0 + hit.barrycentricUV.x * vt1 + hit.barrycentricUV.y * vt2;
    UV.y = 1.0 - UV.y;


    Ray rayDX = generateRay(pixel + uvec2(1, 0));
    Ray rayDY = generateRay(pixel + uvec2(0, 1));

    Ray modelRay = affineTransformRay(ray, instances[hit.instanceIndex].worldToModel0, instances[hit.instanceIndex].worldToModel1, instances[hit.instanceIndex].worldToModel2);
    rayDX = affineTransformRay(rayDX, instances[hit.instanceIndex].worldToModel0, instances[hit.instanceIndex].worldToModel1, instances[hit.instanceIndex].worldToModel2);
    rayDY = affineTransformRay(rayDY, instances[hit.instanceIndex].worldToModel0, instances[hit.instanceIndex].worldToModel1, instances[hit.instanceIndex].worldToModel2);

    
    MollerTriangle trinagle = triangles[hit.primitiveIndex];

    
    vec4 textureDifferential = computeTextureDifferential(modelRay, rayDX, rayDY, hit.dist_to_hit,
                                                vec3(trinagle.vertex_0), vec3(trinagle.edge_vec1), vec3(trinagle.edge_vec2),
                                                vt0, vt1, vt2);

    return textureGrad(textures2D[nonuniformEXT(textureIndex)], UV, vec2(textureDifferential.xy), vec2(textureDifferential.zw));
}

void trace(const in Ray ray, inout Hit hit)
{
    uint rootId = Params.rootIndex;
    uint TLASInstanceLeafIDs[30];
    float tEnter, tExit;
    if (intersectingAABB(ray, vec3(tlasNodes[rootId].bbMin), vec3(tlasNodes[rootId].bbMax), 1e-8, 1e30, tEnter, tExit))
    {

        int leafCount = 0;
        traverseTLAS(ray, rootId, TLASInstanceLeafIDs, tEnter, tExit, leafCount);
        float closestT = 1e30;
        for (int i = 0; i < leafCount; i++)
        {
            uint instanceId = TLASInstanceLeafIDs[i];
            Ray modelRay = affineTransformRay(ray, instances[instanceId].worldToModel0, instances[instanceId].worldToModel1, instances[instanceId].worldToModel2);
            vec3 worldDir = affineTransformDirection(modelRay.direction, instances[instanceId].modelToWorld0, instances[instanceId].modelToWorld1, instances[instanceId].modelToWorld2);
            float modelToWorldScale = length(worldDir);
            float modelToWorldScaleInverse = 1.0 / modelToWorldScale;
            float previousClosestT = closestT;
        
            traverseBLAS(modelRay, hit,
                instances[instanceId].bases01.x,
                instances[instanceId].bases01.y,
                closestT, modelToWorldScale, modelToWorldScaleInverse
            );

            if (hit.primitiveIndex != 0xFFFFFFFFu && closestT < previousClosestT)
            {
                hit.instanceIndex = instanceId;
                hit.world_dist_to_hit = closestT;
            }
        }
        if (closestT == 1e30)
        {
            hit.primitiveIndex = 0xFFFFFFFFu;
            hit.instanceIndex = 0xFFFFFFFFu;
        }
    }
    else
    {
        hit.primitiveIndex = 0xFFFFFFFFu;
        hit.instanceIndex = 0xFFFFFFFFu;
    }

}



float getGGXPDF(const in vec3 normal, const in vec3 outgoing_dir, const in float roughness, const in vec3 candidate_wi)
{
    float Ndotw_o = dot(normal, outgoing_dir);
    float Ndotw_i = dot(normal, candidate_wi);
    if (Ndotw_o <= 1e-6 || Ndotw_i <= 1e-6)
        return 0.0;

    vec3 H = normalize(candidate_wi + outgoing_dir);
    float NdotH = max(dot(normal, H), 0.0);
    float w_odotH = max(dot(outgoing_dir, H), 0.0);

    float alpha = roughness * roughness;

    float D   = GGX_D(NdotH, alpha);
    float G1v = GGX_G1(Ndotw_o, alpha);

    float pdf_h = (D * G1v * w_odotH) / Ndotw_o;

    float pdf_wi = pdf_h / max(4.0 * w_odotH, 1e-6);

    return pdf_wi;
}

void sampleGGX(const in vec3 normal,const in vec3 outgoing_dir, const in float roughness, const in float rand1, const in float rand2, out vec3 incoming_dir, out float PDF)
{
    PDF = 0.0;

    float NdotV = dot(normal, outgoing_dir);
    if (NdotV <= 1e-6)
        return;

    vec3 T, T2;
    buildOrthonormalBasis(normal, T, T2);

    vec3 Vlocal = vec3(dot(outgoing_dir, T), dot(outgoing_dir, T2), dot(outgoing_dir, normal));

    float alpha = roughness * roughness;

    vec3 hLocal = SampleVndf_GGX(vec2(rand1, rand2), normalize(Vlocal), vec2(alpha, alpha));
    hLocal = normalize(hLocal);

    vec3 incoming_local = reflect(-Vlocal, hLocal);
    if (incoming_local.z <= 0.0)
        return;

    vec3 H = normalize(hLocal.x * T + hLocal.y * T2 + hLocal.z * normal);

    incoming_dir = normalize(incoming_local.x * T + incoming_local.y * T2 + incoming_local.z * normal);

    PDF = getGGXPDF(normal, outgoing_dir, roughness, incoming_dir);
}

float getDiffusePDF(const in vec3 normal, const in vec3 candidate_wi)
{
    float cosine = dot(normal, candidate_wi);
    return (cosine > 0.0) ? (cosine * INV_PI) : 0.0;
}

void sampleDiffuse(const in vec3 normal,const in float rand1, const in float rand2 ,out vec3 incoming_dir, out float PDF)
{
    PDF = 0.0;

    float phi = 2.0 * PI * rand1;
    float r   = sqrt(rand2);
    float x   = r * cos(phi);
    float y   = r * sin(phi);
    float z   = sqrt(1.0 - rand2);

    vec3 local_direction = vec3(x, y, z);

    vec3 T1;
    vec3 T2;
    buildOrthonormalBasis(normal, T1, T2);

    incoming_dir = normalize(local_direction.x * T1 + local_direction.y * T2 + local_direction.z * normal);

    PDF = getDiffusePDF(normal, incoming_dir);
}

vec3 evaluateBRDF(const in vec3 normal, const in vec3 incoming_dir, const in vec3 outgoing_dir, const in vec3 baseColor, const in vec3 F0, const in float roughness)
{
    // we need the f value. its f of diffuse + f of specular.
    float Ndotw_i = dot(normal, incoming_dir);
    float Ndotw_o = dot(normal, outgoing_dir);
    if (Ndotw_i <= 1e-6|| Ndotw_o <= 1e-6)
        return vec3(0.0);

    //we calculate f of difuse simple lambertian term
    vec3 f_diffuse = baseColor * INV_PI;

    //we now calculate f of specular GGX
    vec3 H = normalize(incoming_dir + outgoing_dir);
    float NdotH = max(dot(normal, H), 0.0);
    float w_odotH = max(dot(outgoing_dir, H), 0.0);

    float alpha = roughness * roughness;

    float D   = GGX_D(NdotH, alpha);
    float G1v = GGX_G1(Ndotw_o, alpha);
    float G1l = GGX_G1(Ndotw_i, alpha);
    float G   = G1v * G1l;

    vec3 F = fresnel_Schlick(w_odotH, F0);

    vec3 f_specular = (D * G * F) / max(4.0 * Ndotw_i * Ndotw_o, 1e-6);

    //thats it
    return f_diffuse + f_specular;
}

void BRDF(const in vec3 normal, const in vec3 outgoing_dir,
          const in vec3 baseColor, const in vec3 F0, const in float roughness,
          const in float randLobe, const in float rand1, const in float rand2,
          out vec3 incoming_dir, out vec3 BRDF_value, out float BRDF_PDF)
{
    incoming_dir = vec3(0.0);
    BRDF_value = vec3(0.0);
    BRDF_PDF = 0.0;

    // make sure normal and outgoing direction are on the same side.
    float cosineTheta = dot(normal, outgoing_dir);
    if (cosineTheta <= 1e-6)
        return;

    // pick 2 weights such that they add to 1 to pick from diffuse or GGX
    vec3 Fview = fresnel_Schlick(cosineTheta, F0);
    float specular_weight = clamp(max(max(Fview.r, Fview.g), Fview.b), 0.0, 1.0);
    float diffuse_weight = 1.0 - specular_weight;


    vec3 candidate_wi = vec3(0.0);
    float s_pdf = 0.0;
    float d_pdf = 0.0;
    if (randLobe < specular_weight)
    {
        //if we are sampling specular (GGX):
        sampleGGX(normal, outgoing_dir, roughness, rand1, rand2 ,candidate_wi, s_pdf);
        d_pdf = getDiffusePDF(normal,candidate_wi);
    }
    else
    {
        //if we are sampling diffuse (Lambert):
        sampleDiffuse(normal,rand1, rand2, candidate_wi, d_pdf);
        s_pdf = getGGXPDF(normal, outgoing_dir, roughness, candidate_wi);
    }

    //now we can combine the PDF's with the weights used to pick sampling strategy.
    float pdf = specular_weight * s_pdf + diffuse_weight * d_pdf;

    //after some final gates we can assign the out values. for BRDF value we will call the evaluating function
    if (pdf <= 1e-4)
        return;
    incoming_dir = candidate_wi;
    BRDF_value = evaluateBRDF(normal, candidate_wi, outgoing_dir, baseColor, F0, roughness);
    BRDF_PDF = pdf;
}


void evaluateBRDF_and_PDF(const in vec3 normal, const in vec3 outgoing_dir, const in vec3 incoming_dir, const in vec3 baseColor, const in vec3 F0, const in float roughness,
                          out vec3 f,
                          out float pdf)
{
    f   = vec3(0.0);
    pdf = 0.0;

    float cosThetaOut = dot(normal, outgoing_dir);
    if (cosThetaOut <= 1e-6)
        return;

    // Same lobe weights as in BRDF()
    vec3 Fview = fresnel_Schlick(cosThetaOut, F0);
    float specular_weight = clamp(max(max(Fview.r, Fview.g), Fview.b), 0.0, 1.0);
    float diffuse_weight  = 1.0 - specular_weight;

    // Per-lobe PDFs for this specific incoming_dir
    float s_pdf = getGGXPDF(normal, outgoing_dir, roughness, incoming_dir);
    float d_pdf = getDiffusePDF(normal, incoming_dir);

    pdf = specular_weight * s_pdf + diffuse_weight * d_pdf;
    if (pdf <= 0.0)
        return;

    f = evaluateBRDF(normal, incoming_dir, outgoing_dir, baseColor, F0, roughness);
}


void BSDF(const in vec3 normal, const in vec3 outgoing_dir, inout uint rngState,
          const in vec3 baseColor, const in vec3 F0, const in float roughness, const in vec3 emission,
          out vec3 incoming_dir, out vec3 BSDF_value, out float BSDF_PDF)
{
    incoming_dir = vec3(0.0);
    BSDF_value = vec3(0.0);
    BSDF_PDF = 0.0;

    // generate some random values to be used
    float randLobe = rand(rngState);
    float rand1 = rand(rngState);
    float rand2 = rand(rngState);
    // in the future add BTDF branch
    vec3 w_i_BRDF;
    vec3 BRDF_value;
    float BRDF_PDF;

    BRDF(normal, outgoing_dir, baseColor, F0, roughness, randLobe, rand1, rand2, w_i_BRDF, BRDF_value, BRDF_PDF);
    
    if (BRDF_PDF <= 0.0)
        return;
    
    incoming_dir = w_i_BRDF;
    BSDF_value = BRDF_value;
    BSDF_PDF = BRDF_PDF;
}

float sphericalTrianglePDF(vec3 v0, vec3 v1, vec3 v2, vec3 refP)
{
    vec3 a = normalize(v0 - refP);
    vec3 b = normalize(v1 - refP);
    vec3 c = normalize(v2 - refP);

    if (length(a) == 0.0 || length(b) == 0.0 || length(c) == 0.0)
        return 0.0;

    vec3 n_ab = cross(a, b);
    vec3 n_bc = cross(b, c);
    vec3 n_ca = cross(c, a);

    if (dot(n_ab, n_ab) == 0.0 ||
        dot(n_bc, n_bc) == 0.0 ||
        dot(n_ca, n_ca) == 0.0)
        return 0.0;

    n_ab = normalize(n_ab);
    n_bc = normalize(n_bc);
    n_ca = normalize(n_ca);

    float alpha = angleBetween(n_ab, -n_ca);
    float beta  = angleBetween(n_bc, -n_ab);
    float gamma = angleBetween(n_ca, -n_bc);

    float A_pi  = alpha + beta + gamma;
    float A     = A_pi - PI;
    if (A <= 0.0)
        return 0.0;

    return 1.0 / A;
}


bool sampleSphericalTriangle( vec3 v0, vec3 v1, vec3 v2,
                              vec3 refP, vec2 u, 
                              out vec3 out_w, out float out_pdf)
{
    //too lazy to explain this here also LOL. the paper that describes this should be linkedin the read me sources.
    vec3 a = normalize(v0 - refP);
    vec3 b = normalize(v1 - refP);
    vec3 c = normalize(v2 - refP);

    if (length(a) == 0.0 || length(b) == 0.0 || length(c) == 0.0)
        return false;

    vec3 n_ab = cross(a, b);
    vec3 n_bc = cross(b, c);
    vec3 n_ca = cross(c, a);

    if (dot(n_ab, n_ab) == 0.0 ||
        dot(n_bc, n_bc) == 0.0 ||
        dot(n_ca, n_ca) == 0.0)
        return false;

    n_ab = normalize(n_ab);
    n_bc = normalize(n_bc);
    n_ca = normalize(n_ca);

    float alpha = angleBetween(n_ab, -n_ca);
    float beta  = angleBetween(n_bc, -n_ab);
    float gamma = angleBetween(n_ca, -n_bc);

    float A_pi  = alpha + beta + gamma;
    float A     = A_pi - PI;
    if (A <= 0.0) return false;

    out_pdf = 1.0 / A;

    float Ap = u.x * A;
    float Ap_pi = Ap + PI;

    float cosAlpha = cos(alpha);
    float sinAlpha = sin(alpha);

    float sinAp   = sin(Ap_pi);
    float cosAp   = cos(Ap_pi);

    float sinPhi = sinAp * cosAlpha - cosAp * sinAlpha;
    float cosPhi = cosAp * cosAlpha + sinAp * sinAlpha;

    float k1 = cosPhi + cosAlpha;
    float cos_c = dot(a, b);
    float k2 = sinPhi - sinAlpha * cos_c;

    float num   = k2 + differenceOfProducts(k2, cosPhi, k1, sinPhi) * cosAlpha;
    float denom = (sumOfProducts(k2, sinPhi, k1, cosPhi)) * sinAlpha;

    if (abs(denom) < 1e-8)
        return false;

    float cosBp = num / denom;
    cosBp = clamp(cosBp, -1.0, 1.0);
    float sinBp = safeSqrt(1.0 - cosBp * cosBp);

    vec3 c_ortho = gramSchmidt(c, a);
    vec3 cp = cosBp * a + sinBp * normalize(c_ortho);

    float dot_bc = dot(b, cp);
    float cosTheta = 1.0 - u.y * (1.0 - dot_bc);
    cosTheta = clamp(cosTheta, -1.0, 1.0);
    float sinTheta = safeSqrt(1.0 - cosTheta * cosTheta);

    vec3 axis = gramSchmidt(cp, b);
    vec3 w = cosTheta * b + sinTheta * normalize(axis);

    out_w = normalize(w);
    return true;
}

float lightDirectionalPDF(const in vec3 hitPoint, const in uint lightIdx)
{
    // Reconstruct the triangle, compute solid angle pdf for wi,
    // multiply by lightPDF[lightIdx].

    uint instIdx = emissiveTrinagles[lightIdx].instanceIndex;
    uint primIdx = emissiveTrinagles[lightIdx].primitiveIndex;
    MollerTriangle tri = triangles[primIdx];

    vec3 v0_model = vec3(tri.vertex_0);
    vec3 v1_model = v0_model + vec3(tri.edge_vec1);
    vec3 v2_model = v0_model + vec3(tri.edge_vec2);

    vec3 v0_world = affineTransformPoint(v0_model,
                                         instances[instIdx].modelToWorld0,
                                         instances[instIdx].modelToWorld1,
                                         instances[instIdx].modelToWorld2);
    vec3 v1_world = affineTransformPoint(v1_model,
                                         instances[instIdx].modelToWorld0,
                                         instances[instIdx].modelToWorld1,
                                         instances[instIdx].modelToWorld2);
    vec3 v2_world = affineTransformPoint(v2_model,
                                         instances[instIdx].modelToWorld0,
                                         instances[instIdx].modelToWorld1,
                                         instances[instIdx].modelToWorld2);

    // You need a "pdf only" variant of sampleSphericalTriangle or a helper
    // that returns the solid-angle pdf for the *given* direction wi.
    float pdfSolidAngle = sphericalTrianglePDF(v0_world, v1_world, v2_world, hitPoint);

    if (pdfSolidAngle <= 0.0)
        return 0.0;

    return lightPDF[lightIdx] * pdfSolidAngle;
}



bool lightSample(vec3 hitPoint, vec3 normal, inout uint rngState,
                 out vec3 incoming_dir, out vec3 emission, out float pdfDir, out float cosTheta)
{
    incoming_dir = vec3(0.0);
    emission = vec3(0.0);
    pdfDir = 0.0;
    cosTheta = 0.0;


    uint numberOfLights = emissiveTrinagles[0].padding;
    if (numberOfLights == 0u)
        return false;

    float u1 = rand(rngState);
    float u2 = rand(rngState);

    uint k = uint(u1 * float(numberOfLights));
    if (k >= numberOfLights)
        k = numberOfLights - 1u;

    uint lightIdx = (u2 < lightProbability[k]) ? k : LightAlias[k];

    if (lightPDF[lightIdx] <= 0.0)
        return false;

    MollerTriangle tri = triangles[emissiveTrinagles[lightIdx].primitiveIndex];

    uint instIdx = emissiveTrinagles[lightIdx].instanceIndex;

    vec3 v0_model = vec3(tri.vertex_0);
    vec3 v1_model = v0_model + vec3(tri.edge_vec1);
    vec3 v2_model = v0_model + vec3(tri.edge_vec2);

    vec3 v0_world = affineTransformPoint(v0_model,
                                         instances[instIdx].modelToWorld0,
                                         instances[instIdx].modelToWorld1,
                                         instances[instIdx].modelToWorld2);
    vec3 v1_world = affineTransformPoint(v1_model,
                                         instances[instIdx].modelToWorld0,
                                         instances[instIdx].modelToWorld1,
                                         instances[instIdx].modelToWorld2);
    vec3 v2_world = affineTransformPoint(v2_model,
                                         instances[instIdx].modelToWorld0,
                                         instances[instIdx].modelToWorld1,
                                         instances[instIdx].modelToWorld2);

    vec2 u = vec2(rand(rngState), rand(rngState));
    float pdfSolidAngle;

    if (!sampleSphericalTriangle(v0_world, v1_world, v2_world, hitPoint, u, incoming_dir, pdfSolidAngle))
        return false;

    if (pdfSolidAngle <= 0.0)
        return false;

    pdfDir = lightPDF[lightIdx] * pdfSolidAngle;
    if (pdfDir <= 0.0)
        return false;

    Ray shadowRay;
    shadowRay.origin    = hitPoint + 1e-4 * incoming_dir;
    shadowRay.direction = incoming_dir;

    Hit shadowHit = Hit(1e30, 1e30, 0xFFFFFFFFu, 0xFFFFFFFFu, vec2(0.0));
    trace(shadowRay, shadowHit);

    if (shadowHit.instanceIndex != instIdx || shadowHit.primitiveIndex != emissiveTrinagles[lightIdx].primitiveIndex)
        return false;

    cosTheta = max(dot(normal, incoming_dir), 0.0);
    if (cosTheta <= 0.0)
        return false;

    emission = materials[emissiveTrinagles[lightIdx].materialIndex].emission_flags.xyz;

    return true;
}



vec3 solveRenderingEquation(inout Ray ray, inout Hit hit, inout vec3 throughput, inout uint rngState, const in uvec2 pixel, const in int bounce, inout float prev_pdf_B)
{
    vec3 luminance = vec3(0.0);

    //shading trinagle for normal data
    ShadingTriangle trinagle = shadingTris[hit.primitiveIndex];
    vec4 vertex0_data = trinagle.vertexNormal0_uv;
    vec4 vertex1_data = trinagle.vertexNormal1_uv;
    vec4 vertex2_data = trinagle.vertexNormal2_uv;

    //get material for this hit.
    vec4 texture_material = trinagle.texture_materialId;
    uint materialIndex = floatBitsToUint(texture_material.w);
    materialIndex += instances[hit.instanceIndex].bases01.w;
    MaterialGPU material = materials[materialIndex];
    uint textureIndex = floatBitsToUint(material.textureId.x);

    
    //grab the intended base color
    vec3 baseColor = material.baseColor_opacity.xyz;
    if (textureIndex != 0xFFFFFFFFu)
    {
        
    
        vec2 vt0 = vec2(vertex0_data.w, texture_material.x);
        vec2 vt1 = vec2(vertex1_data.w, texture_material.y);
        vec2 vt2 = vec2(vertex2_data.w, texture_material.z);
        
        baseColor *= vec3(getTextureSample(textureIndex, hit, vt0, vt1, vt2, ray, pixel));
    }

    // interpolate the normal and convert it to world space;
    vec3 normal = interpNormal(vertex0_data.xyz, vertex1_data.xyz, vertex2_data.xyz, hit.barrycentricUV.x, hit.barrycentricUV.y);
    //this needs to be swaped for inverse transpose of linnear part of the model->world matrix that needs to be calculated per instance on the cpu
    normal = affineTransformDirection(normal, instances[hit.instanceIndex].modelToWorld0, instances[hit.instanceIndex].modelToWorld1, instances[hit.instanceIndex].modelToWorld2);
    normal = normalize(normal);
    bool frontFace = dot(normal, -ray.direction) > 0.0;
    normal = frontFace ? normal : -normal;
    //get hit point in world space
    vec3 hitPoint = ray.origin + hit.world_dist_to_hit * ray.direction;

    //add direct light BSDF sample to the previous bounce sample if this one is an emmisive trinagle
    uint lightIdx = getLightIndexFromHit(hit.instanceIndex, hit.primitiveIndex);
    if (bounce != 0 && lightIdx != 0xFFFFFFFFu && prev_pdf_B > 0.0)
    {
        float pdf_L_B = lightDirectionalPDF((ray.origin - (1e-4 * -ray.direction)) ,lightIdx);
        float denom = (prev_pdf_B * prev_pdf_B) + (pdf_L_B * pdf_L_B);
        float w_B = (denom > 0.0) ? ((prev_pdf_B * prev_pdf_B) / denom) : 0.0;
        luminance += throughput * w_B * materials[materialIndex].emission_flags.xyz;
    } 

    //get luminacne for first hit.
    if (bounce == 0)
        luminance += throughput * material.emission_flags.xyz;

    //Light sampling branch (direct lighting)
    vec3 wi_L, Li_L;
    float pdf_L, cosTheta_L;

    if (lightSample(hitPoint, normal, rngState, wi_L, Li_L, pdf_L, cosTheta_L))
    {
        vec3 f_L;
        float pdf_B_L;
        evaluateBRDF_and_PDF(normal, -ray.direction, wi_L, baseColor, material.F0_ior_rough.xyz, material.F0_ior_rough.w , f_L, pdf_B_L);
        float denom = (pdf_L * pdf_L) + (pdf_B_L * pdf_B_L);
        float w_L = (denom > 0.0) ? ((pdf_L * pdf_L) / denom) : 0.0;
        if (pdf_L > 0.0 && cosTheta_L > 0.0)
        {
            vec3 C_L = f_L * Li_L * cosTheta_L / pdf_L;
            luminance += w_L * C_L * throughput;
        }
    }

    // BSDF sample next bounce direct term will be added next itteration.
    vec3 wi_B, f_B;
    float pdf_B;

    BSDF(normal, -ray.direction, rngState,
         baseColor, material.F0_ior_rough.xyz, material.F0_ior_rough.w, material.emission_flags.xyz,
         wi_B, f_B, pdf_B);
    if (pdf_B <= 0.0)
    {
        throughput = vec3(0.0);
        return vec3(0.0,0.0,0.0);
    }

    float cosTheta_B = max(dot(normal, wi_B), 0.0);
    prev_pdf_B = pdf_B;

    ray.origin    = hitPoint + 1e-4 * wi_B;
    ray.direction = wi_B;

    if (cosTheta_B > 0.0)
    {
        throughput *= f_B * (cosTheta_B / pdf_B);
    }
    else
    {
        throughput = vec3(0.0);
        return vec3(0.0,0.0,0.0);
    }

    return luminance;
}

vec3 samplePath(Ray ray, uvec2 pixel, inout uint rngState)
{
    vec3 luminacne = vec3(0.0);
    vec3 throughput = vec3(1.0);

    const int MAX_DEPTH = 64;

    bool instanceSelected = (Params.flags & FLAG_INSTANCE_SEL) != 0u;
    uint selectedIdx      = Params.flags & MASK_INSTANCE_IDX;
    float pdf_b_save = 0.0;

    Hit hit = Hit(1e30, 1e30, 0xFFFFFFFFu, 0xFFFFFFFFu, vec2(0.0));
    for (int bounce = 0; bounce < MAX_DEPTH; bounce++)
    {
        trace(ray, hit);
        if (hit.instanceIndex == 0xFFFFFFFFu && hit.primitiveIndex == 0xFFFFFFFFu)
            break;
        if (hit.instanceIndex != 0xFFFFFFFFu && hit.primitiveIndex != 0xFFFFFFFFu)
        {
            luminacne += solveRenderingEquation(ray, hit, throughput, rngState, pixel, bounce, pdf_b_save);
            if (instanceSelected && hit.instanceIndex == selectedIdx && bounce == 0)
                luminacne = mix(luminacne, vec3(1.0, 1.0, 0.0), 0.4);
        }
        if (throughput == vec3(0.0))
            break;

        if (bounce > 3)
        {
            float p = clamp(max(throughput.r, max(throughput.g, throughput.b)), 0.0, 0.99);
            float xi = rand(rngState);
            if (xi > p)
                break;
            throughput /= p;
        }
    }

    return luminacne;
}


// ~~~~~~~~~~~~~ main ~~~~~~~~~~~~~

void main()
{
    //early pixel gate && get pixel XY.
    uvec2 pixel = gl_GlobalInvocationID.xy;
    if (pixel.x >= Params.imageSize.x || pixel.y >= Params.imageSize.y)
        return;

    
    bool bPressedFlag     = (Params.flags & FLAG_B) != 0u;
    
    uint  bInterpRaw      = (Params.flags & B_INTERP_MASK) >> B_INTERP_SHIFT;
    bool  bTransitionPlaying = (bInterpRaw != 0u);
    float bInterp         = float(bInterpRaw) / float(0x3FFu);
    uint pixelIndex = pixel.x + pixel.y * Params.imageSize.x;
    uint rngState = wang_hash(uint(pixelIndex ^ (floatBitsToUint(Params.camPos_time.w) * 1664525u)));
    
    

    vec3 color = vec3(0.0);
    for (int SPP = 0; SPP < 3; SPP++)
    {
        vec2 jitter = vec2(rand(rngState), rand(rngState));
        Ray ray = generateRayJittered(pixel, jitter);
        color += samplePath(ray, pixel, rngState);
    }
    color /= 3.0;

       
    imageStore(outImage, ivec2(pixel), vec4(color, 1.0));
}
