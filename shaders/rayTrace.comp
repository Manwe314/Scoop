#version 460
layout(local_size_x = 8, local_size_y = 8) in;

// ---- outputs ----
layout(set = 0, binding = 0, rgba16f) uniform image2D outImage;

// ---- params (unchanged) ----
layout(set = 0, binding = 5, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;   // treat as TLAS root for this test
    uint  _pad;
} Params;

// ---- TLAS GPU structs/buffers ----
// Must match your CPU packing: 16-byte aligned, runtime arrays last.
struct TLASNodeGPU {
    vec4  bbMin;         // xyz = min
    vec4  bbMax;         // xyz = max
    uvec4 meta;          // x=first, y=count, z=left, w=right
};

layout(set = 0, binding = 6, std430) readonly buffer TLASNodesBuf {
    TLASNodeGPU tlasNodes[];
};

// Per-leaf instance list (global array of instance indices)
layout(set = 0, binding = 8, std430) readonly buffer TLASLeafIndexBuf {
    uint tlasInstanceFirst[]; // a.k.a. instanceIndices on CPU
};

// ---- ray + helpers (same as before) ----
struct Ray { vec3 o; vec3 d; };

Ray makeRay(uvec2 pix)
{
    vec2 uv = (vec2(pix) + 0.5) / vec2(Params.imageSize);
    uv.y = 1.0 - uv.y; // your vertical flip
    vec2 ndc = uv * 2.0 - 1.0;

    vec4 p0 = Params.viewProjInv * vec4(ndc, 0.0, 1.0);
    vec4 p1 = Params.viewProjInv * vec4(ndc, 1.0, 1.0);
    p0 /= p0.w; p1 /= p1.w;

    Ray r; r.o = Params.camPos_time.xyz; r.d = normalize(p1.xyz - p0.xyz);
    return r;
}

bool intersectAABB(vec3 bmin, vec3 bmax, Ray r, out float tNear, out float tFar)
{
    vec3 invD = 1.0 / r.d;
    vec3 t0 = (bmin - r.o) * invD;
    vec3 t1 = (bmax - r.o) * invD;
    vec3 tmin3 = min(t0, t1);
    vec3 tmax3 = max(t0, t1);
    tNear = max(max(tmin3.x, tmin3.y), tmin3.z);
    tFar  = min(min(tmax3.x, tmax3.y), tmax3.z);
    return tFar >= max(tNear, 0.0);
}

void orderByNear(float tNL, float tNR, out uint firstIdx, out uint secondIdx, uint L, uint R)
{
    bool leftFirst = (tNL <= tNR);
    firstIdx = leftFirst ? L : R;
    secondIdx = leftFirst ? R : L;
}

// tiny hash → color for visualization
vec3 hashColor(uint x)
{
    x ^= x >> 17; x *= 0xed5ad4bbu;
    x ^= x >> 11; x *= 0xac4c1b51u;
    x ^= x >> 15; x *= 0x31848babu;
    vec3 c = vec3(float( x        & 255u),
                  float((x >> 8)  & 255u),
                  float((x >> 16) & 255u)) / 255.0;
    // brighten a bit
    return mix(c, vec3(1.0), 0.25);
}

void main()
{
    uvec2 pix = gl_GlobalInvocationID.xy;
    if (pix.x >= Params.imageSize.x || pix.y >= Params.imageSize.y) return;

    // quick sanity: valid root and non-empty TLAS?
    if (tlasNodes.length() == 0 || Params.rootIndex >= tlasNodes.length()) {
        imageStore(outImage, ivec2(pix), vec4(1,0,0,1)); // red = bad TLAS
        return;
    }

    Ray ray = makeRay(pix);

    // iterative traversal (TLAS only)
    const int  STACK_MAX = 64;
    uint stack[STACK_MAX];
    int  sp = 0;
    stack[sp++] = Params.rootIndex;

    float closestNear = 1e30;
    bool  gotLeaf = false;
    uint  leafFirst = 0u;
    uint  leafCount = 0u;

    while (sp > 0)
    {
        uint ni = stack[--sp];
        if (ni >= tlasNodes.length()) continue; // robust guard

        TLASNodeGPU n = tlasNodes[ni];

        // children info
        uint first = n.meta.x;   // for leaf: first into tlasInstanceFirst[]
        uint count = n.meta.y;   // for leaf: number of instances
        uint left  = n.meta.z;   // for internal: left child node index
        uint right = n.meta.w;   // for internal: right child node index

        // test AABBs (for internal nodes we'll use children bounds; for leaves, node.bounds contains union)
        float tNL, tFL, tNR, tFR;
        bool hitL = false, hitR = false;

        // We need children bounds to do near-first ordering; assume internal node's bbMin/bbMax are not child bounds.
        // Easiest: test this node's bounds to gate traversal; if miss, continue.
        float tN, tF;
        if (!intersectAABB(n.bbMin.xyz, n.bbMax.xyz, ray, tN, tF)) continue;

        // Leaf or internal?
        bool leaf = (count > 0u); // matches CPU packing
        if (leaf) {
            // Keep the nearest leaf by entry distance tN
            if (tN < closestNear) {
                closestNear = tN;
                gotLeaf = true;
                leafFirst = first;
                leafCount = count;
            }
            // We *could* break here, but keep scanning in case an even nearer leaf exists on the stack
            continue;
        }

        // Internal: intersect children to do near-first push.
        // (If child indices can be invalid, guard them; otherwise assume valid.)
        TLASNodeGPU L = (left  < tlasNodes.length()) ? tlasNodes[left]  : n;
        TLASNodeGPU R = (right < tlasNodes.length()) ? tlasNodes[right] : n;

        hitL = (left  < tlasNodes.length()) && intersectAABB(L.bbMin.xyz, L.bbMax.xyz, ray, tNL, tFL);
        hitR = (right < tlasNodes.length()) && intersectAABB(R.bbMin.xyz, R.bbMax.xyz, ray, tNR, tFR);

        if (!hitL && !hitR) continue;

        if (hitL && hitR) {
            uint f, s;
            orderByNear(tNL, tNR, f, s, left, right);
            if (sp < STACK_MAX) stack[sp++] = s;
            if (sp < STACK_MAX) stack[sp++] = f;
        } else if (hitL) {
            if (sp < STACK_MAX) stack[sp++] = left;
        } else { // hitR
            if (sp < STACK_MAX) stack[sp++] = right;
        }
    }

    vec3 color;
    if (!gotLeaf) {
        // miss color
        color = vec3(1.0, 1.0, 1.0);
    } else {
        // get an instance index from the leaf's list
        // Common case in your builder: count == 1; still guard the range.
        uint base = leafFirst;
        uint idxCount = tlasInstanceFirst.length();
        uint instIdx = (idxCount > 0u && base < idxCount) ? tlasInstanceFirst[base] : 0u;

        // visualize: hash instance index → color
        color = hashColor(instIdx);
    }

    imageStore(outImage, ivec2(pix), vec4(color, 1.0));
}
