#version 460
// ------ Cpu side passed Objects -------
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D outImage;

struct SBVHNode {
    vec4 bbMin_left__left_start;
    vec4 bbMax_left__left_count;
    vec4 bbMin_right__right_start;
    vec4 bbMax_right__right_count;
};

struct MollerTriangle {
    vec4 vertex_0;
    vec4 edge_vec1;
    vec4 edge_vec2;
    vec4 normal_mat;
};

struct ShadingTriangle {
    vec4 vertexNormal0_uv;
    vec4 vertextNormal1_uv;
    vec4 vertexNormal2_uv;
};

struct MaterialGPU {
    vec4 baseColor_opacity;
    vec4 F0_ior_rough;
    vec4 emission_flags;
    vec4 textureId;
};

layout(set = 0, binding = 1, std430) readonly buffer BVHNodesBuf { SBVHNode        bvhNodes[]; };
layout(set = 0, binding = 2, std430) readonly buffer MollerBuf   { MollerTriangle  triangles[]; };
layout(set = 0, binding = 3, std430) readonly buffer ShadeBuf    { ShadingTriangle shadingTris[]; };
layout(set = 0, binding = 4, std430) readonly buffer MtlBuf      { MaterialGPU     materials[];  };

layout(set = 0, binding = 5, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;
    uint  _pad;
} Params;

struct TLASNodeGPU {
    vec4  bbMin;           
    vec4  bbMax;          
    uvec4 meta;            // x=first, y=count, z=left, w=right
};

struct InstanceDataGPU {
    vec4 modelToWorld0;
    vec4 modelToWorld1;
    vec4 modelToWorld2;

    vec4 worldToModel0;
    vec4 worldToModel1;
    vec4 worldToModel2;

    vec4 aabbMin;
    vec4 aabbMax;

    uvec4 bases01; // x=nodeBase, y=triBase, z=shadeTriBase, w=materialBase
    uvec4 bases23; // x=textureBase, y=sbvhRoot
};

layout(set = 0, binding = 6, std430) readonly buffer TLASNodesBuf { TLASNodeGPU      tlasNodes[];   };
layout(set = 0, binding = 7, std430) readonly buffer InstanceBuf  { InstanceDataGPU  instances[];   };

// ---------- RayTracing Engine ----------

struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 color;
};

float rand(uvec2 pixel)
{
    float time = Params.camPos_time.w;
    return fract(sin(dot(pixel + time, vec2(12.9898, 78.233))) * 43758.5453);
}


Ray generateRay(uvec2 pixel)
{
    vec2 UV = (vec2(pixel) + 0.5) / vec2(Params.imageSize);
    UV.y = 1 - UV.y;

    vec2 normalisedDeviceCoordinate = UV * 2.0 - 1.0;

    vec2 nearPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 0.0, 1.0);
    vec2 farPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 1.0, 1.0);

    vec3 point0 = nearPoint.xyz / nearPoint.w;
    vec3 point1 = farPoint.xyz / farPoint.w;

    Ray ray;
    ray.origin = Params.camPos_time.xyz;
    ray.direction = normalize(point1 - point0);
    ray.color = vec3(0.0);
    return ray;
}



void main()
{
    uvec2 pixel = gl_GlobalInvocationID.xy;
    if (pixel.x >= Params.imageSize.x || pixel.y >= Params.imageSize.y)
        return;
    Ray ray = generateRay(pixel);
    float terminate = 0.0;
    while (1)
    {
        //recursive traversal of TLAS
        // miss logic or BLAS hit
        // recursive traversal of BLAS
        // miss logic or trinagle hit
        // task based sampling over OMEGA hemisphere
        // update Ray color based on sampling output
        if (terminate < 1.0)
            // update Ray origin and direction based on 
        else
            break;
    }


    
    imageStore(outImage, ivec2(pix), vec4(ray.color, 1.0));
}
