#version 460
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 8, local_size_y = 8) in;

// --------- Scene data (set 0) ----------
struct SBVHNode {
    vec4 bbMin_left__left_start;
    vec4 bbMax_left__left_count;
    vec4 bbMin_right__right_start;
    vec4 bbMax_right__right_count;
};

struct MollerTriangle {
    vec4 vertex_0;
    vec4 edge_vec1;
    vec4 edge_vec2;
};

struct ShadingTriangle {
    vec4 vertexNormal0_uv;
    vec4 vertexNormal1_uv;
    vec4 vertexNormal2_uv;
    vec4 texture_materialId;
};

struct MaterialGPU {
    vec4 baseColor_opacity;
    vec4 F0_ior_rough;
    vec4 emission_flags;
    vec4 textureId;
};

layout(set = 0, binding = 0, std430) readonly buffer BVHNodesBuf { SBVHNode        bvhNodes[]; };
layout(set = 0, binding = 1, std430) readonly buffer MollerBuf   { MollerTriangle  triangles[]; };
layout(set = 0, binding = 2, std430) readonly buffer ShadeBuf    { ShadingTriangle shadingTris[]; };
layout(set = 0, binding = 3, std430) readonly buffer MtlBuf      { MaterialGPU     materials[];  };

// --------- TLAS / instances (set 1) ----------
struct TLASNodeGPU {
    vec4  bbMin;           
    vec4  bbMax;          
    uvec4 meta;            // x=first, y=count, z=left, w=right
};

struct InstanceDataGPU {
    vec4 modelToWorld0;
    vec4 modelToWorld1;
    vec4 modelToWorld2;

    vec4 worldToModel0;
    vec4 worldToModel1;
    vec4 worldToModel2;

    vec4 aabbMin;
    vec4 aabbMax;

    uvec4 bases0; // x=nodeBase, y=triBase, z=shadeTriBase, w=materialBase
    uvec4 bases1; // x=textureBase, y=sbvhRoot, w=triLightOffset
};

layout(set = 1, binding = 0, std430) readonly buffer TLASNodesBuf { TLASNodeGPU      tlasNodes[];   };
layout(set = 1, binding = 1, std430) readonly buffer InstanceBuf  { InstanceDataGPU  instances[];   };
layout(set = 1, binding = 2, std430) readonly buffer InstIdxBuf   { uint             instanceIndices[]; };
layout(set = 1, binding = 19, std430) readonly buffer PrevInstanceBuf  { InstanceDataGPU  prevInstances[];   };
layout(set = 1, binding = 20, std430) readonly buffer PrevInstIdxBuf   { uint             prevInstanceIndices[]; };

layout(set = 1, binding = 3, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;
    uint  flags;
    vec2  cameraJitter;
    vec2  cameraJitterPrev;
} Params;

// NRD input storage images (set 1)
layout(set = 1, binding = 11, rgba16_snorm)  uniform image2D nrdNormalRoughness;
layout(set = 1, binding = 12, r32f)          uniform image2D nrdViewZ;
layout(set = 1, binding = 13, rgba16f)    uniform image2D nrdMotionVec;

// prev camera data + prev viewZ (set 1)
layout(set = 1, binding = 16, std430) readonly buffer PrevCamBuf {
    mat4 prevV;
    mat4 prevVP;
    mat4 currVP;
    mat4 currV;
} prev;

layout(set = 1, binding = 17, r32f) uniform readonly image2D prevViewZImage;

// --------- Dynamic buffers (set 2) ----------
struct RayData {
    vec4 origin;
    vec4 direction;
};

struct HitIds {
    uint instanceIndex;
    uint primitiveIndex;
};

struct Hitdata {
    float worldT;
    float localT;
    float baryU;
    float baryV;
};

layout(set = 2, binding = 13, std430) buffer PrimaryRayBuf     { RayData   primaryRays[];     };
layout(set = 2, binding = 14, std430) buffer PrimaryHitIdsBuf  { HitIds    primaryHitIds[];   };
layout(set = 2, binding = 15, std430) buffer PrimaryHitdataBuf { Hitdata   primaryHitdata[];  };

// ---------- Helpers ----------

const uint INVALID_INSTANCE_INDEX = 0xFFFFFFFFu;

vec3 getWorldPosition(uint idx, out HitIds ids, out Hitdata hit, out RayData ray)
{
    ids = primaryHitIds[idx];
    hit = primaryHitdata[idx];
    ray = primaryRays[idx];

    // World position = traced ray origin + t * direction
    return ray.origin.xyz + ray.direction.xyz * hit.worldT;
}

vec3 getWorldNormal(uint instIdx, uint primIdx, float baryU, float baryV)
{
    uint shadeIdx = instances[instIdx].bases0.z + primIdx;
    ShadingTriangle tri = shadingTris[shadeIdx];

    vec3 n0 = tri.vertexNormal0_uv.xyz;
    vec3 n1 = tri.vertexNormal1_uv.xyz;
    vec3 n2 = tri.vertexNormal2_uv.xyz;

    float b0 = 1.0 - baryU - baryV;
    float b1 = baryU;
    float b2 = baryV;

    // Interpolated object-space normal
    vec3 nObj = normalize(n0 * b0 + n1 * b1 + n2 * b2);

    InstanceDataGPU inst = instances[instIdx];

    // Assuming modelToWorld rows hold the 3x3 rotation/scale
    mat3 m2w = mat3(inst.modelToWorld0.xyz,
                    inst.modelToWorld1.xyz,
                    inst.modelToWorld2.xyz);

    vec3 nWorld = normalize(m2w * nObj);

    return nWorld;
}

float getRoughness(uint instIdx, uint primIdx)
{
    uint shadeIdx = instances[instIdx].bases0.z + primIdx;
    ShadingTriangle tri = shadingTris[shadeIdx];
    vec4 texMat = tri.texture_materialId;
    uint materialIndex = floatBitsToUint(texMat.w) + instances[instIdx].bases0.w;
    MaterialGPU m = materials[materialIndex];
    return m.F0_ior_rough.w;
}

// Row-major 3x4 affine multiply (instance matrices are stored by rows)
vec3 transformPointRowMajor(const InstanceDataGPU inst, vec3 p)
{
    return vec3(dot(inst.modelToWorld0.xyz, p) + inst.modelToWorld0.w,
                dot(inst.modelToWorld1.xyz, p) + inst.modelToWorld1.w,
                dot(inst.modelToWorld2.xyz, p) + inst.modelToWorld2.w);
}

// Barycentric position in object space using Moller triangle data (v0, v1-v0, v2-v0)
vec3 getObjectPosition(uint triIndex, float baryU, float baryV)
{
    MollerTriangle tri = triangles[triIndex];

    return tri.vertex_0.xyz
         + baryU * tri.edge_vec1.xyz
         + baryV * tri.edge_vec2.xyz;
}

void writeNrdInputs(uvec2 pixel)
{
    if (pixel.x >= Params.imageSize.x || pixel.y >= Params.imageSize.y)
        return;

    uint idx = pixel.x + pixel.y * Params.imageSize.x;

    HitIds ids;
    Hitdata hit;
    RayData ray;
    getWorldPosition(idx, ids, hit, ray);

    // Miss / sky
    if (ids.instanceIndex == INVALID_INSTANCE_INDEX) {
        imageStore(nrdViewZ,           ivec2(pixel), vec4(65504.0, 0.0, 0.0, 0.0));
        imageStore(nrdMotionVec,       ivec2(pixel), vec4(0.0, 0.0, 0.0, 0.0));
        imageStore(nrdNormalRoughness, ivec2(pixel), vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }

    // If instanceIndices[] remaps, use it here instead
    uint instIdx = ids.instanceIndex;
    InstanceDataGPU instCurr = instances[instIdx];
    InstanceDataGPU instPrev = prevInstances[instIdx];


    // Object-space hit position from barycentrics
    vec3 objPos = getObjectPosition(ids.primitiveIndex, hit.baryU, hit.baryV);

    // World-space hit positions in current and previous frames
    vec3 worldPosCurr = transformPointRowMajor(instCurr, objPos);
    vec3 worldPosPrev = transformPointRowMajor(instPrev, objPos);

    //===========================
    // 1) View-space Z (current)
    //===========================

    // world -> view (current and previous)
    vec4 viewPosCurr = prev.currV * vec4(worldPosCurr, 1.0);
    vec4 viewPosPrev = prev.prevV * vec4(worldPosPrev, 1.0);

    // Linear view Z, positive forward (flip sign if your convention differs)
    float viewZCurr = -viewPosCurr.z;
    float viewZPrev = -viewPosPrev.z;

    imageStore(nrdViewZ, ivec2(pixel), vec4(viewZCurr, 0.0, 0.0, 0.0));

    //===================================
    // 2) Normal + Roughness
    //===================================

    vec3 nWorld = getWorldNormal(instIdx, ids.primitiveIndex, hit.baryU, hit.baryV);
    float roughness = getRoughness(instIdx, ids.primitiveIndex);

    imageStore(nrdNormalRoughness, ivec2(pixel), vec4(nWorld, roughness));

    //===================================
    // 3) 2.5D motion vector:
    //    xy = prevUV - currUV
    //    z  = prevViewZ - currViewZ
    //===================================

    // world -> clip
    vec4 clipCurr = prev.currVP * vec4(worldPosCurr, 1.0);
    vec4 clipPrev = prev.prevVP * vec4(worldPosPrev, 1.0);

    // NDC [-1, 1]
    vec2 ndcCurr = clipCurr.xy / clipCurr.w;
    vec2 ndcPrev = clipPrev.xy / clipPrev.w;

    // UV [0, 1]
    vec2 uvCurr = ndcCurr * 0.5 + 0.5;
    vec2 uvPrev = ndcPrev * 0.5 + 0.5;

    // Rect size (in pixels)
    vec2 rectSize = vec2(Params.imageSize);

    // IN_MV.xy in *pixels* (matches NRD sample)
    vec2 mvXY = (uvPrev - uvCurr) * rectSize;

    // IN_MV.z in view-space units (same convention as IN_VIEWZ)
    float mvZ = viewZPrev - viewZCurr;

    imageStore(nrdMotionVec, ivec2(pixel), vec4(mvXY, mvZ, 0.0));
}

void main()
{
    uvec2 pixel = gl_GlobalInvocationID.xy;
    writeNrdInputs(pixel);
}
