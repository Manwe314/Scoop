errors:


to-add later:
    unspliting in SBVH construction;
    add a tab on Ui App for key binding + general stats? at index -2?
    add inverse transpose of linnear part for normal transform model->world

tomorrow?
    eval BRDF
    per pixel loop total

for read me:
    warrinings
    what i wouldve upgraded.
    mtl files use K phong data not P PBR data.


    


sources:

https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf
https://www.nvidia.in/docs/IO/77714/sbvh.pdf
https://nils-olovsson.se/articles/ear_clipping_triangulation/#citation-chazelle1991
https://raytracing.github.io/books/RayTracingInOneWeekend.html#rays,asimplecamera,andbackground
https://www.graphics.cornell.edu/pubs/1997/MT97.pdf
https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/
https://en.wikipedia.org/wiki/Wavefront_.obj_file
https://en.wikipedia.org/wiki/Affine_transformation
https://en.wikipedia.org/wiki/Mipmap
https://graphics.stanford.edu/papers/trd/trd_jpg.pdf
https://www.youtube.com/playlist?list=PLmIqTlJ6KsE2yXzeq02hqCDpOdtj6n6A9
https://graphics.stanford.edu/courses/cs348b-18-spring-content/lectures/12_reflection2/12_reflection2_slides.pdf
https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf
https://medium.com/@uwa4d/physically-based-rendering-more-accurate-microsurface-distribution-function-ggx-3968fc09fa48
https://graphicscompendium.com/gamedev/15-pbr
https://arxiv.org/pdf/2306.05044
https://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html
https://shi-yan.github.io/webgpuunleashed/Basics/mipmapping_and_anisotropic_filtering.html
https://www.pbr-book.org/4ed/Shapes/Triangle_Meshes
https://en.wikipedia.org/wiki/Alias_method
https://dl.acm.org/doi/pdf/10.1145/218380.218500
https://cw.fel.cvut.cz/b241/_media/courses/b4m39rso/tutorials/multiple_importance_sampling_101.pdf

moller 64 bytes - lunox
[GPU] compute: 3.807 ms, graphics: 0.259 ms, combined: 4.066 ms
[CPU] avg FPS: 191.965 avg MS: 5.209
[GPU] compute: 3.808 ms, graphics: 0.282 ms, combined: 4.091 ms
[CPU] avg FPS: 192.040 avg MS: 5.207
[GPU] compute: 4.346 ms, graphics: 0.264 ms, combined: 4.609 ms
[CPU] avg FPS: 191.934 avg MS: 5.210
[GPU] compute: 4.738 ms, graphics: 0.302 ms, combined: 5.040 ms
[CPU] avg FPS: 191.917 avg MS: 5.211
[GPU] compute: 3.803 ms, graphics: 0.257 ms, combined: 4.060 ms
[CPU] avg FPS: 191.710 avg MS: 5.216
[GPU] compute: 4.306 ms, graphics: 0.288 ms, combined: 4.595 ms
[CPU] avg FPS: 191.894 avg MS: 5.211
[GPU] compute: 3.808 ms, graphics: 0.267 ms, combined: 4.075 ms
[CPU] avg FPS: 191.973 avg MS: 5.209


moller 64 bytes - just a girl translate 0 -50 -100
[GPU] compute: 48.353 ms, graphics: 0.290 ms, combined: 48.644 ms
[CPU] avg FPS: 20.268 avg MS: 49.339
[GPU] compute: 48.297 ms, graphics: 0.322 ms, combined: 48.620 ms
[CPU] avg FPS: 20.266 avg MS: 49.344
[GPU] compute: 48.432 ms, graphics: 0.281 ms, combined: 48.714 ms
[CPU] avg FPS: 20.262 avg MS: 49.354
[GPU] compute: 49.080 ms, graphics: 0.315 ms, combined: 49.395 ms
[CPU] avg FPS: 20.262 avg MS: 49.354
[GPU] compute: 48.291 ms, graphics: 0.278 ms, combined: 48.569 ms
[CPU] avg FPS: 20.260 avg MS: 49.358
[GPU] compute: 48.682 ms, graphics: 0.324 ms, combined: 49.006 ms
[CPU] avg FPS: 20.260 avg MS: 49.359


moller 48 bytes - lunox
[GPU] compute: 4.287 ms, graphics: 0.271 ms, combined: 4.558 ms
[CPU] avg FPS: 193.786 avg MS: 5.160
[GPU] compute: 4.256 ms, graphics: 0.296 ms, combined: 4.552 ms
[CPU] avg FPS: 193.819 avg MS: 5.159
[GPU] compute: 3.800 ms, graphics: 0.264 ms, combined: 4.065 ms
[CPU] avg FPS: 193.808 avg MS: 5.160
[GPU] compute: 3.840 ms, graphics: 0.314 ms, combined: 4.154 ms
[CPU] avg FPS: 193.998 avg MS: 5.155
[GPU] compute: 4.371 ms, graphics: 0.252 ms, combined: 4.623 ms
[CPU] avg FPS: 194.279 avg MS: 5.147
[GPU] compute: 3.807 ms, graphics: 0.307 ms, combined: 4.114 ms
[CPU] avg FPS: 194.301 avg MS: 5.147


moller 48 bytes - just a girl 
[GPU] compute: 48.317 ms, graphics: 0.302 ms, combined: 48.618 ms
[CPU] avg FPS: 20.033 avg MS: 49.919
[GPU] compute: 48.712 ms, graphics: 0.319 ms, combined: 49.031 ms
[CPU] avg FPS: 20.036 avg MS: 49.910
[GPU] compute: 47.985 ms, graphics: 0.293 ms, combined: 48.278 ms
[CPU] avg FPS: 20.034 avg MS: 49.915
[GPU] compute: 49.053 ms, graphics: 0.333 ms, combined: 49.386 ms
[CPU] avg FPS: 20.038 avg MS: 49.906
[GPU] compute: 48.067 ms, graphics: 0.298 ms, combined: 48.366 ms
[CPU] avg FPS: 20.036 avg MS: 49.911
[GPU] compute: 49.144 ms, graphics: 0.352 ms, combined: 49.495 ms
[CPU] avg FPS: 20.039 avg MS: 49.902


moller 48 bytes - lunox With Texture sampling
[GPU] compute: 4.2788 ms, graphics: 0.279115 ms, combined: 4.55792 ms
[CPU] avg FPS: 196.709 avg MS: 5.08365
[GPU] compute: 4.49714 ms, graphics: 0.271719 ms, combined: 4.76885 ms
[CPU] avg FPS: 196.761 avg MS: 5.0823
[GPU] compute: 3.79693 ms, graphics: 0.27724 ms, combined: 4.07417 ms
[CPU] avg FPS: 197.017 avg MS: 5.0757
[GPU] compute: 3.77615 ms, graphics: 0.275052 ms, combined: 4.0512 ms
[CPU] avg FPS: 197.039 avg MS: 5.07513
[GPU] compute: 3.74187 ms, graphics: 0.279271 ms, combined: 4.02115 ms
[CPU] avg FPS: 197.357 avg MS: 5.06695
[GPU] compute: 4.04052 ms, graphics: 0.276354 ms, combined: 4.31687 ms
[CPU] avg FPS: 197.541 avg MS: 5.06224

moller 48 bytes - lunox with texture sampling + struct retreval
[GPU] compute: 5.54656 ms, graphics: 0.272917 ms, combined: 5.81948 ms
[CPU] avg FPS: 202.191 avg MS: 4.94583
[GPU] compute: 3.68089 ms, graphics: 0.269323 ms, combined: 3.95021 ms
[CPU] avg FPS: 202.243 avg MS: 4.94455
[GPU] compute: 3.68312 ms, graphics: 0.269427 ms, combined: 3.95255 ms
[CPU] avg FPS: 202.213 avg MS: 4.94528
[GPU] compute: 4.34922 ms, graphics: 0.279948 ms, combined: 4.62917 ms
[CPU] avg FPS: 202.241 avg MS: 4.94461
[GPU] compute: 3.68453 ms, graphics: 0.26401 ms, combined: 3.94854 ms
[CPU] avg FPS: 202.252 avg MS: 4.94433
[GPU] compute: 3.67797 ms, graphics: 0.283594 ms, combined: 3.96156 ms
[CPU] avg FPS: 202.469 avg MS: 4.93902
[GPU] compute: 5.16328 ms, graphics: 0.284479 ms, combined: 5.44776 ms
[CPU] avg FPS: 202.204 avg MS: 4.9455
[GPU] compute: 4.3699 ms, graphics: 0.278177 ms, combined: 4.64807 ms
[CPU] avg FPS: 202.119 avg MS: 4.94759
[GPU] compute: 3.95385 ms, graphics: 0.272187 ms, combined: 4.22604 ms
[CPU] avg FPS: 202.506 avg MS: 4.93812


moller 48 bytes - just a girl with texture CHECK + struct retrival
[GPU] compute: 50.6249 ms, graphics: 0.305208 ms, combined: 50.9301 ms
[CPU] avg FPS: 19.4466 avg MS: 51.4228
[GPU] compute: 50.2675 ms, graphics: 0.326198 ms, combined: 50.5937 ms
[CPU] avg FPS: 19.4461 avg MS: 51.4241
[GPU] compute: 49.944 ms, graphics: 0.300052 ms, combined: 50.2441 ms
[CPU] avg FPS: 19.4433 avg MS: 51.4315
[GPU] compute: 51.0345 ms, graphics: 0.353906 ms, combined: 51.3884 ms
[CPU] avg FPS: 19.4452 avg MS: 51.4265
[GPU] compute: 49.9785 ms, graphics: 0.301927 ms, combined: 50.2805 ms
[CPU] avg FPS: 19.4461 avg MS: 51.4241
[GPU] compute: 50.4696 ms, graphics: 0.324062 ms, combined: 50.7937 ms
[CPU] avg FPS: 19.4422 avg MS: 51.4344
[GPU] compute: 50.7889 ms, graphics: 0.308437 ms, combined: 51.0973 ms
[CPU] avg FPS: 19.4414 avg MS: 51.4365


moller 48 bytes - lunox w/ texture sampling & Updated TLAS / BLAS traversal.
[GPU] compute: 3.395 ms, graphics: 0.321 ms, combined: 3.717 ms
[CPU] avg FPS: 222.885 avg MS: 4.487
[GPU] compute: 3.398 ms, graphics: 0.293 ms, combined: 3.691 ms
[CPU] avg FPS: 222.808 avg MS: 4.488
[GPU] compute: 3.395 ms, graphics: 0.308 ms, combined: 3.703 ms
[CPU] avg FPS: 222.806 avg MS: 4.488
[GPU] compute: 3.983 ms, graphics: 0.300 ms, combined: 4.283 ms
[CPU] avg FPS: 222.428 avg MS: 4.496
[GPU] compute: 3.401 ms, graphics: 0.297 ms, combined: 3.698 ms
[CPU] avg FPS: 222.464 avg MS: 4.495
[GPU] compute: 3.400 ms, graphics: 0.282 ms, combined: 3.683 ms
[CPU] avg FPS: 222.179 avg MS: 4.501
[GPU] compute: 4.072 ms, graphics: 0.322 ms, combined: 4.393 ms
[CPU] avg FPS: 222.074 avg MS: 4.503


moller 48 bytes - just a girl (0 -50 -100) w/ updated TLAS / BLAS traversal

[GPU] compute: 51.188 ms, graphics: 0.393 ms, combined: 51.581 ms
[CPU] avg FPS: 19.600 avg MS: 51.021
[GPU] compute: 50.281 ms, graphics: 0.409 ms, combined: 50.691 ms
[CPU] avg FPS: 19.496 avg MS: 51.292
[GPU] compute: 51.100 ms, graphics: 0.391 ms, combined: 51.491 ms
[CPU] avg FPS: 19.394 avg MS: 51.562
[GPU] compute: 52.140 ms, graphics: 0.414 ms, combined: 52.554 ms
[CPU] avg FPS: 19.289 avg MS: 51.842
[GPU] compute: 50.998 ms, graphics: 0.384 ms, combined: 51.382 ms
[CPU] avg FPS: 19.193 avg MS: 52.104
[GPU] compute: 50.752 ms, graphics: 0.411 ms, combined: 51.163 ms
[CPU] avg FPS: 19.154 avg MS: 52.209


m48 model + full ray differential sampling w/amd dGPU & sharing mode exclusive
[GPU] compute: 31.910 ms, graphics: 0.250 ms, combined: 32.161 ms
[CPU] avg FPS: 35.315 avg MS: 28.317
[GPU] compute: 31.896 ms, graphics: 0.250 ms, combined: 32.146 ms
[CPU] avg FPS: 35.277 avg MS: 28.347
[GPU] compute: 31.909 ms, graphics: 0.251 ms, combined: 32.160 ms
[CPU] avg FPS: 35.249 avg MS: 28.370
[GPU] compute: 31.909 ms, graphics: 0.250 ms, combined: 32.159 ms
[CPU] avg FPS: 35.211 avg MS: 28.400
[GPU] compute: 31.612 ms, graphics: 0.248 ms, combined: 31.860 ms
[CPU] avg FPS: 35.157 avg MS: 28.444
[GPU] compute: 31.611 ms, graphics: 0.250 ms, combined: 31.862 ms
[CPU] avg FPS: 35.102 avg MS: 28.488
[GPU] compute: 31.910 ms, graphics: 0.250 ms, combined: 32.159 ms
[CPU] avg FPS: 35.022 avg MS: 28.554


m48 model + full ray differential sampling w/ iGPU & sharing mode exclusive
[GPU] compute: 115.994 ms, graphics: 0.323 ms, combined: 116.317 ms
[CPU] avg FPS: 7.853 avg MS: 127.333
[GPU] compute: 116.882 ms, graphics: 0.357 ms, combined: 117.239 ms
[CPU] avg FPS: 7.864 avg MS: 127.155
[GPU] compute: 118.866 ms, graphics: 0.345 ms, combined: 119.211 ms
[CPU] avg FPS: 7.872 avg MS: 127.032
[GPU] compute: 116.887 ms, graphics: 0.382 ms, combined: 117.269 ms
[CPU] avg FPS: 7.879 avg MS: 126.926
[GPU] compute: 119.024 ms, graphics: 0.336 ms, combined: 119.360 ms
[CPU] avg FPS: 7.886 avg MS: 126.810
[GPU] compute: 117.654 ms, graphics: 0.347 ms, combined: 118.001 ms
[CPU] avg FPS: 7.893 avg MS: 126.687
[GPU] compute: 117.220 ms, graphics: 0.332 ms, combined: 117.552 ms
[CPU] avg FPS: 7.901 avg MS: 126.559
[GPU] compute: 116.980 ms, graphics: 0.343 ms, combined: 117.323 ms
[CPU] avg FPS: 7.910 avg MS: 126.422

m48 model + full ray differential sampling w/ iGPU & sharing mode concurent
[GPU] compute: 131.044 ms, graphics: 0.326 ms, combined: 131.369 ms
[CPU] avg FPS: 8.443 avg MS: 118.435
[GPU] compute: 134.424 ms, graphics: 0.369 ms, combined: 134.793 ms
[CPU] avg FPS: 8.395 avg MS: 119.122
[GPU] compute: 134.047 ms, graphics: 0.339 ms, combined: 134.386 ms
[CPU] avg FPS: 8.346 avg MS: 119.817
[GPU] compute: 135.099 ms, graphics: 0.331 ms, combined: 135.429 ms
[CPU] avg FPS: 8.299 avg MS: 120.501
[GPU] compute: 133.651 ms, graphics: 0.330 ms, combined: 133.981 ms
[CPU] avg FPS: 8.253 avg MS: 121.168
[GPU] compute: 131.869 ms, graphics: 0.313 ms, combined: 132.183 ms
[CPU] avg FPS: 8.208 avg MS: 121.835
[GPU] compute: 131.897 ms, graphics: 0.331 ms, combined: 132.227 ms
[CPU] avg FPS: 8.163 avg MS: 122.497
[GPU] compute: 131.867 ms, graphics: 0.321 ms, combined: 132.187 ms
[CPU] avg FPS: 8.117 avg MS: 123.191


m48 model + full ray differential sampling w/ amd dGPU & sharing mode concurent
[GPU] compute: 24.813 ms, graphics: 0.250 ms, combined: 25.062 ms
[CPU] avg FPS: 37.681 avg MS: 26.539
[GPU] compute: 24.813 ms, graphics: 0.250 ms, combined: 25.063 ms
[CPU] avg FPS: 37.710 avg MS: 26.518
[GPU] compute: 24.807 ms, graphics: 0.249 ms, combined: 25.057 ms
[CPU] avg FPS: 37.744 avg MS: 26.494
[GPU] compute: 24.811 ms, graphics: 0.249 ms, combined: 25.060 ms
[CPU] avg FPS: 37.780 avg MS: 26.469
[GPU] compute: 25.011 ms, graphics: 0.248 ms, combined: 25.260 ms
[CPU] avg FPS: 37.824 avg MS: 26.438
[GPU] compute: 24.816 ms, graphics: 0.249 ms, combined: 25.065 ms
[CPU] avg FPS: 37.868 avg MS: 26.407


m48 final Simple comp shader w/ iGPU lunox
[GPU] compute: 3.63167 ms, graphics: 0.270885 ms, combined: 3.90255 ms
[CPU] avg FPS: 240.653 avg MS: 4.15535
[GPU] compute: 3.14255 ms, graphics: 0.268177 ms, combined: 3.41073 ms
[CPU] avg FPS: 241.203 avg MS: 4.14589
[GPU] compute: 3.14812 ms, graphics: 0.271302 ms, combined: 3.41943 ms
[CPU] avg FPS: 241.218 avg MS: 4.14562
[GPU] compute: 3.68297 ms, graphics: 0.264844 ms, combined: 3.94781 ms
[CPU] avg FPS: 241.34 avg MS: 4.14353
[GPU] compute: 3.69625 ms, graphics: 0.27901 ms, combined: 3.97526 ms
[CPU] avg FPS: 241.125 avg MS: 4.14723
[GPU] compute: 3.99234 ms, graphics: 0.276354 ms, combined: 4.2687 ms
[CPU] avg FPS: 240.699 avg MS: 4.15457
[GPU] compute: 3.15073 ms, graphics: 0.272031 ms, combined: 3.42276 ms
[CPU] avg FPS: 240.701 avg MS: 4.15453
[GPU] compute: 4.04167 ms, graphics: 0.271562 ms, combined: 4.31323 ms
[CPU] avg FPS: 240.553 avg MS: 4.15709

m48 final Simple comp shader w/ iGPu just a girl
[GPU] compute: 73.4875 ms, graphics: 0.376042 ms, combined: 73.8635 ms
[CPU] avg FPS: 16.2435 avg MS: 61.563
[GPU] compute: 72.4809 ms, graphics: 0.453073 ms, combined: 72.934 ms
[CPU] avg FPS: 16.1443 avg MS: 61.9414
[GPU] compute: 73.6702 ms, graphics: 0.39526 ms, combined: 74.0654 ms
[CPU] avg FPS: 16.0447 avg MS: 62.3258
[GPU] compute: 71.0971 ms, graphics: 0.325 ms, combined: 71.4221 ms
[CPU] avg FPS: 15.9504 avg MS: 62.6945
[GPU] compute: 71.0134 ms, graphics: 0.316406 ms, combined: 71.3298 ms
[CPU] avg FPS: 15.8579 avg MS: 63.0601
[GPU] compute: 70.7717 ms, graphics: 0.31349 ms, combined: 71.0852 ms
[CPU] avg FPS: 15.7674 avg MS: 63.4218
[GPU] compute: 71.2671 ms, graphics: 0.302552 ms, combined: 71.5697 ms
[CPU] avg FPS: 15.6769 avg MS: 63.7881
[GPU] compute: 71.2867 ms, graphics: 0.306771 ms, combined: 71.5934 ms
[CPU] avg FPS: 15.5868 avg MS: 64.157
[GPU] compute: 72.1598 ms, graphics: 0.31474 ms, combined: 72.4746 ms
[CPU] avg FPS: 15.4965 avg MS: 64.5307

m48 final Simple comp shader w/ iGPU & O3 lunox
[GPU] compute: 4.60693 ms, graphics: 0.293698 ms, combined: 4.90062 ms
[CPU] avg FPS: 241.587 avg MS: 4.13929
[GPU] compute: 3.14943 ms, graphics: 0.273125 ms, combined: 3.42255 ms
[CPU] avg FPS: 241.543 avg MS: 4.14005
[GPU] compute: 3.14365 ms, graphics: 0.274687 ms, combined: 3.41833 ms
[CPU] avg FPS: 241.535 avg MS: 4.14019
[GPU] compute: 3.66807 ms, graphics: 0.26901 ms, combined: 3.93708 ms
[CPU] avg FPS: 241.706 avg MS: 4.13726
[GPU] compute: 3.75979 ms, graphics: 0.271354 ms, combined: 4.03115 ms
[CPU] avg FPS: 241.544 avg MS: 4.14003
[GPU] compute: 3.14594 ms, graphics: 0.271458 ms, combined: 3.4174 ms
[CPU] avg FPS: 241.527 avg MS: 4.14033
[GPU] compute: 3.14443 ms, graphics: 0.27224 ms, combined: 3.41667 ms
[CPU] avg FPS: 241.577 avg MS: 4.13947
[GPU] compute: 3.78745 ms, graphics: 0.291771 ms, combined: 4.07922 ms
[CPU] avg FPS: 241.24 avg MS: 4.14525


m48 final Simple comp shader w/ iGpu & O3 just a girl
[GPU] compute: 70.7747 ms, graphics: 0.325937 ms, combined: 71.1006 ms
[CPU] avg FPS: 13.9133 avg MS: 71.8736
[GPU] compute: 70.9957 ms, graphics: 0.29474 ms, combined: 71.2905 ms
[CPU] avg FPS: 13.9133 avg MS: 71.8736
[GPU] compute: 71.0902 ms, graphics: 0.324115 ms, combined: 71.4143 ms
[CPU] avg FPS: 13.9127 avg MS: 71.8767
[GPU] compute: 70.8108 ms, graphics: 0.31401 ms, combined: 71.1248 ms
[CPU] avg FPS: 13.9132 avg MS: 71.8743
[GPU] compute: 70.9621 ms, graphics: 0.320312 ms, combined: 71.2824 ms
[CPU] avg FPS: 13.9129 avg MS: 71.8756
[GPU] compute: 70.858 ms, graphics: 0.301354 ms, combined: 71.1593 ms
[CPU] avg FPS: 13.9128 avg MS: 71.8764
[GPU] compute: 71.2709 ms, graphics: 0.320365 ms, combined: 71.5913 ms
[CPU] avg FPS: 13.9122 avg MS: 71.8792
[GPU] compute: 70.796 ms, graphics: 0.29349 ms, combined: 71.0895 ms
[CPU] avg FPS: 13.9126 avg MS: 71.8772
[GPU] compute: 71.2023 ms, graphics: 0.329635 ms, combined: 71.5319 ms
[CPU] avg FPS: 13.9123 avg MS: 71.8788




#version 460
#extension GL_EXT_nonuniform_qualifier : enable
// ------ Cpu side passed Objects -------
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D outImage;

struct SBVHNode {
    vec4 bbMin_left__left_start;
    vec4 bbMax_left__left_count;
    vec4 bbMin_right__right_start;
    vec4 bbMax_right__right_count;
};

struct MollerTriangle {
    vec4 vertex_0;
    vec4 edge_vec1;
    vec4 edge_vec2;
};

struct ShadingTriangle {
    vec4 vertexNormal0_uv;
    vec4 vertexNormal1_uv;
    vec4 vertexNormal2_uv;
    vec4 texture_materialId;
};

struct MaterialGPU {
    vec4 baseColor_opacity;
    vec4 F0_ior_rough;
    vec4 emission_flags;
    vec4 textureId;
};

layout(set = 0, binding = 1, std430) readonly buffer BVHNodesBuf { SBVHNode        bvhNodes[]; };
layout(set = 0, binding = 2, std430) readonly buffer MollerBuf   { MollerTriangle  triangles[]; };
layout(set = 0, binding = 3, std430) readonly buffer ShadeBuf    { ShadingTriangle shadingTris[]; };
layout(set = 0, binding = 4, std430) readonly buffer MtlBuf      { MaterialGPU     materials[];  };

layout(set = 0, binding = 5, std430) readonly buffer ParamsBuf {
    mat4  viewProjInv;
    vec4  camPos_time;
    uvec2 imageSize;
    uint  rootIndex;
    uint  flags;
} Params;

struct TLASNodeGPU {
    vec4  bbMin;           
    vec4  bbMax;          
    uvec4 meta;            // x=first, y=count, z=left, w=right
};

struct InstanceDataGPU {
    vec4 modelToWorld0;
    vec4 modelToWorld1;
    vec4 modelToWorld2;

    vec4 worldToModel0;
    vec4 worldToModel1;
    vec4 worldToModel2;

    vec4 aabbMin;
    vec4 aabbMax;

    uvec4 bases01; // x=nodeBase, y=triBase, z=shadeTriBase, w=materialBase
    uvec4 bases23; // x=textureBase, y=sbvhRoot
};

struct EmisiveTrinagle {
    uint primitiveIndex;
    uint instanceIndex;
    uint materialIndex;
    uint padding;
};

layout(set = 0, binding = 6, std430) readonly buffer TLASNodesBuf { TLASNodeGPU      tlasNodes[];   };
layout(set = 0, binding = 7, std430) readonly buffer InstanceBuf  { InstanceDataGPU  instances[];   };
layout(set = 0, binding = 8, std430) readonly buffer InstIdxBuf { uint instanceIndices[]; };
layout(set = 0, binding = 9) uniform sampler2D textures2D[];
layout(set = 0, binding = 10, std430) readonly buffer EmissiveTriBuf {EmisiveTrinagle emissiveTrinagles[]; };
layout(set = 0, binding = 11, std430) readonly buffer LightProb { float lightProbability[]; };
layout(set = 0, binding = 12, std430) readonly buffer LightPdf { float lightPDF[]; };
layout(set = 0, binding = 13, std430) readonly buffer LightAli { uint LightAlias[]; };

// ---------- RayTracing Engine ----------


//~~~~~~~~~~~~~ comp specific data structs & constants ~~~~~~~~~~~~~
struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Hit {
    float dist_to_hit;
    float world_dist_to_hit;
    uint instanceIndex;
    uint primitiveIndex;
    vec2 barrycentricUV;
};

const uint FLAG_B            = 1u << 31;
const uint FLAG_INSTANCE_SEL = 1u << 30;
const uint B_INTERP_SHIFT    = 20u;
const uint B_INTERP_MASK     = 0x3FFu << B_INTERP_SHIFT;
const uint MASK_INSTANCE_IDX = 0xFu;
const float PI      = 3.14159265358979323846;
const float INV_PI  = 0.31830988618379067154;
const vec3 sunDir = normalize(vec3(0.5, 0.5, 0.0));
const float sunAngularRadius = 0.2;
const float sunCosAngle = cos(sunAngularRadius);
const vec3 skyColor = vec3(0.0);
const vec3 sunColor = vec3(20.0, 20.0, 18.0);


//~~~~~~~~~~~~~ helpers ~~~~~~~~~~~~~

uint wang_hash(uint s)
{
    s = (s ^ 61u) ^ (s >> 16);
    s *= 9u;
    s = s ^ (s >> 4);
    s *= 0x27d4eb2du;
    s = s ^ (s >> 15);
    return s;
}

uint xorshift(inout uint state)
{
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    return state;
}

float floatConstruct(uint state)
{
    const uint ieeeMantissa = 0x007FFFFFu;
    const uint ieeeOne      = 0x3F800000u;

    state &= ieeeMantissa;
    state |= ieeeOne;

    float  f = uintBitsToFloat(state);
    return f - 1.0;
}

float rand(inout uint state)
{
    return floatConstruct(wang_hash(xorshift(state)));
}

void swap(inout float a, inout float b)
{
    float temp = a;
    a = b;
    b = temp;
}

float safeSqrt(float x) {
    return sqrt(max(x, 0.0));
}

float angleBetween(vec3 a, vec3 b) {
    return acos(clamp(dot(a, b), -1.0, 1.0));
}

vec3 gramSchmidt(vec3 v, vec3 n) {
    return normalize(v - n * dot(v, n));
}

float differenceOfProducts(float a, float b, float c, float d) {
    return a * b - c * d;
}

float sumOfProducts(float a, float b, float c, float d) {
    return a * b + c * d;
}


vec3 affineTransformPoint(const in vec3 point, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    return vec3(dot(row0.xyz, point) + row0.w,
                dot(row1.xyz, point) + row1.w,
                dot(row2.xyz, point) + row2.w);
}

vec3 affineTransformDirection(const in vec3 direction, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    return vec3(dot(row0.xyz, direction),
                dot(row1.xyz, direction),
                dot(row2.xyz, direction));
}

Ray affineTransformRay(const in Ray ray, const in vec4 row0, const in vec4 row1, const in vec4 row2)
{
    Ray newRay;
    newRay.origin = affineTransformPoint(ray.origin, row0, row1, row2); 
    newRay.direction = affineTransformDirection(ray.direction, row0, row1, row2);
    return newRay;
}

vec3 interpNormal(const in vec3 normal0, const in vec3 normal1, const in vec3 normal2, const in float u, const in float v)
{
    float w = 1.0 - u - v;
    vec3 normal = w * normal0 + u * normal1 + v * normal2;
    return normalize(normal);
}


float intersectPlane(const in Ray ray, const in vec3 P0, const in vec3 N)
{
    float denom = dot(ray.direction, N);
    if (denom == 0)
        denom = 1e-8;
    return dot(P0 - ray.origin, N) / denom;
}

vec3 fresnel_Schlick(const in float cosTheta, const in vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float GGX_D(const in float NdotH,const in float alpha)
{
    float a2 = alpha * alpha;
    float d  = NdotH * NdotH * (a2 - 1.0) + 1.0;
    return a2 / (PI * d * d);
}

float GGX_G1(const in float NdotX,const in float alpha)
{
    if (NdotX <= 0.0) return 0.0;
    float a2 = alpha * alpha;
    float NdotX2 = NdotX * NdotX;
    float denom = NdotX + sqrt(a2 + (1.0 - a2) * NdotX2);
    return (2.0 * NdotX) / max(denom, 1e-6);
}

void buildOrthonormalBasis(const in vec3 normal, out vec3 T1, out vec3 T2)
{
    if (abs(normal.z) < 0.999)
        T1 = normalize(cross(normal, vec3(0.0, 0.0, 1.0)));
    else
        T1 = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));

    T2 = cross(normal, T1);
}

vec3 SampleVndf_Hemisphere(const in vec2 rand,const in vec3 incoming_dir)
{
    float phi = 2.0f * PI * rand.x;
    float z = fma((1.0f - rand.y), (1.0f + incoming_dir.z), -incoming_dir.z);
    float sinTheta = sqrt(clamp(1.0f - z * z, 0.0f, 1.0f));
    float x = sinTheta * cos(phi);
    float y = sinTheta * sin(phi);
    vec3 c = vec3(x, y, z);
    vec3 h = c + incoming_dir;
    return h;
}

vec3 SampleVndf_GGX(const in vec2 rand, const in vec3 incoming_dir, const in vec2 alpha)
{
    vec3 incoming_dir_std = normalize(vec3(incoming_dir.xy * alpha, incoming_dir.z));
    vec3 wmStd = SampleVndf_Hemisphere(rand, incoming_dir_std);
    vec3 wm = normalize(vec3(wmStd.xy * alpha, wmStd.z));
    return wm;
}

//temp
vec3 hsv2rgb(vec3 c) {
    vec3 p = abs(fract(c.x + vec3(0,2,4)/6.0)*6.0 - 3.0);
    return c.z * mix(vec3(1.0), clamp(p-1.0,0.0,1.0), c.y);
}
vec3 directionHue(vec3 n) {
    n = normalize(n);
    float az = atan(n.z, n.x);
    float el = asin(clamp(n.y, -1.0, 1.0));
    float H = (az / (2.0*3.14159265)) + 0.5;
    float S = 0.7;
    float V = 0.5 + 0.5 * (el/(0.5*3.14159265));
    return hsv2rgb(vec3(H,S,V));
}

//~~~~~~~~~~~~~ core functions ~~~~~~~~~~~~~

vec3 evalSunEnvironment(vec3 dir)
{
    float cosTheta = dot(normalize(dir), sunDir);

    if (cosTheta > sunCosAngle)
        return sunColor;
    else
        return skyColor;
}

vec4 computeTextureDifferential(const in Ray ray, const in Ray rayDX, const in Ray rayDY, const in float tHit, const in vec3 v0, const in vec3 e1, const in vec3 e2, const in vec2 uv0, const in vec2 uv1, const in vec2 uv2)
{
    //too lazy to explain this here hopefully there is more detail in ReadMe.md lol
    vec3 normal = normalize(cross(e1, e2));
    
    vec3 P = ray.origin + tHit * ray.direction;
    
    float tHitDx = intersectPlane(rayDX, v0, normal);
    float tHitDy = intersectPlane(rayDY, v0, normal);
    
    vec3 Px = rayDX.origin + tHitDx * rayDX.direction;
    vec3 Py = rayDY.origin + tHitDy * rayDY.direction;
   
    vec3 dPdx = Px - P;
    vec3 dPdy = Py - P;
    
    vec2 duv1 = uv1 - uv0;
    vec2 duv2 = uv2 - uv0;
    
    float r = 1.0 / (duv1.x * duv2.y - duv1.y * duv2.x);
    vec3 dPdu = (e1 * duv2.y - e2 * duv1.y) * r;
    vec3 dPdv = (e2 * duv1.x - e1 * duv2.x) * r;

    float a = dot(dPdu, dPdu);
    float b = dot(dPdu, dPdv);
    float c = dot(dPdv, dPdv);

    float det = a * c - b * b;
    if (abs(det) < 1E-8)
        return vec4(0.0, 0.0, 0.0, 0.0);
    float ex = dot(dPdu, dPdx);
    float fx = dot(dPdv, dPdx);

    float dudx = (c * ex - b * fx) / det;
    float dvdx = (-b * ex + a * fx) / det;

    float ey = dot(dPdu, dPdy);
    float fy = dot(dPdv, dPdy);

    float dudy = (c * ey - b * fy) / det;
    float dvdy = (-b * ey + a * fy) / det;

    vec2 dTdx = vec2(dudx, dvdx);
    vec2 dTdy = vec2(dudy, dvdy);

    dTdx.y = -dTdx.y;
    dTdy.y = -dTdy.y;

    return vec4(dTdx, dTdy);
}

Ray generateRay(const in uvec2 pixel)
{
    vec2 UV = (vec2(pixel) + 0.5) / vec2(Params.imageSize);

    vec2 normalisedDeviceCoordinate = UV * 2.0 - 1.0;

    vec4 nearPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 0.0, 1.0);
    vec4 farPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 1.0, 1.0);

    vec3 point0 = nearPoint.xyz / nearPoint.w;
    vec3 point1 = farPoint.xyz / farPoint.w;

    Ray ray;
    ray.origin = Params.camPos_time.xyz;
    ray.direction = normalize(point1 - point0);
    return ray;
}

Ray generateRayJittered(uvec2 pixel, vec2 jitter)
{
    vec2 pixelSample = vec2(pixel) + jitter;

    vec2 UV = pixelSample / vec2(Params.imageSize);
    vec2 normalisedDeviceCoordinate = UV * 2.0 - 1.0;

    vec4 nearPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 0.0, 1.0);
    vec4 farPoint = Params.viewProjInv * vec4(normalisedDeviceCoordinate, 1.0, 1.0);

    vec3 point0 = nearPoint.xyz / nearPoint.w;
    vec3 point1 = farPoint.xyz / farPoint.w;

    Ray ray;
    ray.origin = Params.camPos_time.xyz;
    ray.direction = normalize(point1 - point0);
    return ray;
}

bool intersectingAABB(const in Ray ray, const in vec3 bbMin, const in vec3 bbMax, const in float tMin, const in float tMax, inout float tEnter, inout float tExit)
{
    //ray forula for point P along the ray at some distance t from origin:
    // P(t) = O + t * D where O is Origin vec3 and D is Normalized vec3 Direction. 
    float t0 = tMin;
    float t1 = tMax;

    for (int axis = 0; axis < 3; axis++)
    {
        float originI = ray.origin[axis];
        float directionI = ray.direction[axis];
        float minBoxA = bbMin[axis];
        float maxBoxA = bbMax[axis];

        if (abs(directionI) <= 1e-8)
        {
            if (originI < minBoxA || originI > maxBoxA)
                return false;

        }
        else
        {
            float inverseDirectionI = 1.0 / directionI;
            float tNearA = (minBoxA - originI) * inverseDirectionI;
            float tFarA = (maxBoxA - originI) * inverseDirectionI;
            if (tNearA > tFarA)
                swap(tNearA, tFarA);
            
            t0 = tNearA > t0 ? tNearA : t0;
            t1 = tFarA < t1 ? tFarA : t1;
            if (t1 < t0)
                return false;
        }
    }
    tEnter = t0;
    tExit = t1;
    return (tExit >= tMin) && (tEnter <= tMax);
}

bool moller_trumbore(const in Ray ray, inout Hit hit, const in vec3 vertex_0, const in vec3 edge_1, const in vec3 edge_2, inout float min_distance)
{
    //algorithm final form:
    /*
       | t |                     | Q . edge2 |
       | u | = 1 / (P . edge1) * |   P . T   |
       | v |                     |   Q . D   |
    */
    //where:
    /*
        D - Nromalized ray direction
        P = D X edge2
        Q = T X edge1
        T = O - vertex0
        O - ray Origin
    */
    vec3 P = cross(ray.direction, edge_2);
    float det = dot(P, edge_1);

    if (abs(det) <= 1e-8)
        return false;
    
    float inverse_det = 1 / det;
    vec3 T = ray.origin - vertex_0;

    float u = dot(T, P) * inverse_det;
    if (u < 0.0 || u > 1.0)
        return false;
    
    vec3 Q = cross(T, edge_1);
    float v = dot(ray.direction, Q) * inverse_det;
    if (v < 0.0 || (v + u) > 1.0)
        return false;
    float t = dot(edge_2, Q) * inverse_det;
    if (t < 1e-4)
        return false;
    if (t < min_distance)
    {
        min_distance = t;
        hit.dist_to_hit = t;
        hit.barrycentricUV.x = u;
        hit.barrycentricUV.y = v;
        return true;
    }
    return false;
}

void traverseTLAS(const in Ray ray, const in uint root, inout uint instancesOut[30], const in float tEnter, const in float tExit, out int outPutPointer)
{
    uint stack[30];
    int stackPointer = 0;
    stack[stackPointer] = root;
    outPutPointer = 0;
        

    while (stackPointer >= 0)
    {
        float tNearLeft, tNearRight, tFarLeft, tFarRight;

        uvec4 meta = tlasNodes[stack[stackPointer]].meta;
        if (meta.y > 0)
        {
            uint instanceI = instanceIndices[meta.x];
            Ray modelRay = affineTransformRay(ray, instances[instanceI].worldToModel0, instances[instanceI].worldToModel1, instances[instanceI].worldToModel2);
            vec3 bbmin = vec3(instances[instanceI].aabbMin);
            vec3 bbmax = vec3(instances[instanceI].aabbMax);
            float tNear, tFar;
            if (intersectingAABB(modelRay, bbmin, bbmax, tEnter, tExit, tNear, tFar))
            {
                vec3 pModel = modelRay.origin + tNear * modelRay.direction;
                vec3 pWorld = affineTransformPoint(pModel,
                                instances[instanceI].modelToWorld0,
                                instances[instanceI].modelToWorld1,
                                instances[instanceI].modelToWorld2);
                float tNearWorld = dot(pWorld - ray.origin, normalize(ray.direction));
                if (outPutPointer < 30)
                {
                    instancesOut[outPutPointer] = instanceI;
                    outPutPointer++;
                }
            }
        
            stackPointer--;
            continue;
        }
        TLASNodeGPU leftNode = tlasNodes[meta.z];
        TLASNodeGPU rightNode = tlasNodes[meta.w];

        vec3 left_bbMin = vec3(leftNode.bbMin);
        vec3 left_bbMax = vec3(leftNode.bbMax);

        vec3 right_bbMin = vec3(rightNode.bbMin);
        vec3 right_bbMax = vec3(rightNode.bbMax);

        bool hitLeft = intersectingAABB(ray, left_bbMin, left_bbMax, tEnter, tExit, tNearLeft, tFarLeft);
        bool hitRight = intersectingAABB(ray, right_bbMin, right_bbMax, tEnter, tExit, tNearRight, tFarRight);

        if (hitLeft && hitRight)
        {
            if (tNearLeft > tNearRight)
            {
                stack[stackPointer] = meta.z;
                stackPointer++;
                stack[stackPointer] = meta.w;
            }
            else
            {
                stack[stackPointer] = meta.w;
                stackPointer++;
                stack[stackPointer] = meta.z;
            }
        }
        else if (hitLeft)
            stack[stackPointer] = meta.z;
        else if (hitRight)
            stack[stackPointer] = meta.w;
        else
            stackPointer--;
    }
}


void traverseBLAS(const in Ray ray, inout Hit hit, const in uint nodeOffset, const in uint triBase, inout float closestT, const in float modelToWorldScale, const in float modelToWorldScaleInverse)
{
    const float ORDER_EPS = 1e-6;

    uint stack[64];
    int  stackPointer = 0;
    stack[stackPointer] = nodeOffset;


    while (stackPointer >= 0)
    {

        float tNearLeft, tNearRight, tFarLeft, tFarRight;

        SBVHNode node = bvhNodes[stack[stackPointer]];

        vec4 left_count_n_max = node.bbMax_left__left_count;
        vec3 left_bbMax       = vec3(left_count_n_max);
        uint left_count       = floatBitsToUint(left_count_n_max.w);

        vec4 left_start_n_min = node.bbMin_left__left_start;
        vec3 left_bbMin       = vec3(left_start_n_min);
        uint left_start       = floatBitsToUint(left_start_n_min.w);

        if (left_count != 0xFFFFFFFFu)
        {
            float tNearLeaf, tFarLeaf;
            bool leafHit = intersectingAABB(ray, left_bbMin, left_bbMax, 1e-6, closestT * modelToWorldScaleInverse, tNearLeaf, tFarLeaf);
            if (!leafHit || tNearLeaf * modelToWorldScale >= closestT)
            {
                stackPointer--;
                continue;
            }

            float min_distance = closestT * modelToWorldScaleInverse;
            uint  primIndex    = 0xFFFFFFFFu;

            for (uint i = 0; i < left_count; i++)
            {
                uint prim = left_start + triBase + i;
                MollerTriangle triangle = triangles[prim];
                if (moller_trumbore(ray, hit,
                                    vec3(triangle.vertex_0),
                                    vec3(triangle.edge_vec1),
                                    vec3(triangle.edge_vec2),
                                    min_distance))
                {
                    primIndex = prim;
                }
            }
            if (primIndex != 0xFFFFFFFFu)
            {
                closestT = min_distance * modelToWorldScale;
                hit.primitiveIndex = primIndex;
            }
            stackPointer--;
            continue;
        }

        vec3 right_bbMax = vec3(node.bbMax_right__right_count);

        vec4 right_start_n_Min = node.bbMin_right__right_start;
        vec3 right_bbMin       = vec3(right_start_n_Min);
        uint right_start       = floatBitsToUint(right_start_n_Min.w);


        bool hitLeft  = intersectingAABB(ray, left_bbMin,  left_bbMax,  1e-6, closestT * modelToWorldScaleInverse, tNearLeft,  tFarLeft);
        bool hitRight = intersectingAABB(ray, right_bbMin, right_bbMax, 1e-6, closestT * modelToWorldScaleInverse, tNearRight, tFarRight);

        if ( (!hitLeft  || tNearLeft  * modelToWorldScale >= closestT) &&
             (!hitRight || tNearRight * modelToWorldScale >= closestT) )
        {
            stackPointer--;
            continue;
        }

        if (hitLeft && hitRight)
        {
            bool leftIsNear = (abs(tNearLeft - tNearRight) > ORDER_EPS) ? (tNearLeft < tNearRight) : (left_start < right_start);

            uint nearIdx = leftIsNear ? (left_start  + nodeOffset) : (right_start + nodeOffset);
            uint farIdx  = leftIsNear ? (right_start + nodeOffset) : (left_start  + nodeOffset);

            stack[stackPointer] = farIdx;
            stackPointer++;
            stack[stackPointer] = nearIdx;
        }
        else if (hitLeft)
        {
            stack[stackPointer] = left_start + nodeOffset;
        }
        else
        {
            stack[stackPointer] = right_start + nodeOffset;
        }
    }
}

vec4 getTextureSample(const in uint textureIndex, inout Hit hit, const in vec2 vt0, const in vec2 vt1, const in vec2 vt2, const in Ray ray, const in uvec2 pixel)
{
    vec2 UV = (1.0 - hit.barrycentricUV.x - hit.barrycentricUV.y) * vt0 + hit.barrycentricUV.x * vt1 + hit.barrycentricUV.y * vt2;
    UV.y = 1.0 - UV.y;


    Ray rayDX = generateRay(pixel + uvec2(1, 0));
    Ray rayDY = generateRay(pixel + uvec2(0, 1));

    Ray modelRay = affineTransformRay(ray, instances[hit.instanceIndex].worldToModel0, instances[hit.instanceIndex].worldToModel1, instances[hit.instanceIndex].worldToModel2);
    rayDX = affineTransformRay(rayDX, instances[hit.instanceIndex].worldToModel0, instances[hit.instanceIndex].worldToModel1, instances[hit.instanceIndex].worldToModel2);
    rayDY = affineTransformRay(rayDY, instances[hit.instanceIndex].worldToModel0, instances[hit.instanceIndex].worldToModel1, instances[hit.instanceIndex].worldToModel2);

    
    MollerTriangle trinagle = triangles[hit.primitiveIndex];

    
    vec4 textureDifferential = computeTextureDifferential(modelRay, rayDX, rayDY, hit.dist_to_hit,
                                                vec3(trinagle.vertex_0), vec3(trinagle.edge_vec1), vec3(trinagle.edge_vec2),
                                                vt0, vt1, vt2);

    return textureGrad(textures2D[nonuniformEXT(textureIndex)], UV, vec2(textureDifferential.xy), vec2(textureDifferential.zw));
}

void trace(const in Ray ray, inout Hit hit)
{
    uint rootId = Params.rootIndex;
    uint TLASInstanceLeafIDs[30];
    float tEnter, tExit;
    if (intersectingAABB(ray, vec3(tlasNodes[rootId].bbMin), vec3(tlasNodes[rootId].bbMax), 1e-8, 1e30, tEnter, tExit))
    {

        int leafCount = 0;
        traverseTLAS(ray, rootId, TLASInstanceLeafIDs, tEnter, tExit, leafCount);
        float closestT = 1e30;
        for (int i = 0; i < leafCount; i++)
        {
            uint instanceId = TLASInstanceLeafIDs[i];
            Ray modelRay = affineTransformRay(ray, instances[instanceId].worldToModel0, instances[instanceId].worldToModel1, instances[instanceId].worldToModel2);
            vec3 worldDir = affineTransformDirection(modelRay.direction, instances[instanceId].modelToWorld0, instances[instanceId].modelToWorld1, instances[instanceId].modelToWorld2);
            float modelToWorldScale = length(worldDir);
            float modelToWorldScaleInverse = 1.0 / modelToWorldScale;
            float previousClosestT = closestT;
        
            traverseBLAS(modelRay, hit,
                instances[instanceId].bases01.x,
                instances[instanceId].bases01.y,
                closestT, modelToWorldScale, modelToWorldScaleInverse
            );

            if (hit.primitiveIndex != 0xFFFFFFFFu && closestT < previousClosestT)
            {
                hit.instanceIndex = instanceId;
                hit.world_dist_to_hit = closestT;
            }
        }
    }

}



float getGGXPDF(const in vec3 normal, const in vec3 outgoing_dir, const in float roughness, const in vec3 candidate_wi)
{
    float Ndotw_o = dot(normal, outgoing_dir);
    float Ndotw_i = dot(normal, candidate_wi);
    if (Ndotw_o <= 1e-6 || Ndotw_i <= 1e-6)
        return 0.0;

    vec3 H = normalize(candidate_wi + outgoing_dir);
    float NdotH = max(dot(normal, H), 0.0);
    float w_odotH = max(dot(outgoing_dir, H), 0.0);

    float alpha = roughness * roughness;

    float D   = GGX_D(NdotH, alpha);
    float G1v = GGX_G1(Ndotw_o, alpha);

    float pdf_h = (D * G1v * w_odotH) / Ndotw_o;

    float pdf_wi = pdf_h / max(4.0 * w_odotH, 1e-6);

    return pdf_wi;
}

void sampleGGX(const in vec3 normal,const in vec3 outgoing_dir, const in float roughness, const in float rand1, const in float rand2, out vec3 incoming_dir, out float PDF)
{
    PDF = 0.0;

    float NdotV = dot(normal, outgoing_dir);
    if (NdotV <= 1e-6)
        return;

    vec3 T, T2;
    buildOrthonormalBasis(normal, T, T2);

    vec3 Vlocal = vec3(dot(outgoing_dir, T), dot(outgoing_dir, T2), dot(outgoing_dir, normal));

    float alpha = roughness * roughness;

    vec3 hLocal = SampleVndf_GGX(vec2(rand1, rand2), normalize(Vlocal), vec2(alpha, alpha));
    hLocal = normalize(hLocal);

    vec3 incoming_local = reflect(-Vlocal, hLocal);
    if (incoming_local.z <= 0.0)
        return;

    vec3 H = normalize(hLocal.x * T + hLocal.y * T2 + hLocal.z * normal);

    incoming_dir = normalize(incoming_local.x * T + incoming_local.y * T2 + incoming_local.z * normal);

    PDF = getGGXPDF(normal, outgoing_dir, roughness, incoming_dir);
}

float getDiffusePDF(const in vec3 normal, const in vec3 candidate_wi)
{
    float cosine = dot(normal, candidate_wi);
    return (cosine > 0.0) ? (cosine * INV_PI) : 0.0;
}

void sampleDiffuse(const in vec3 normal,const in float rand1, const in float rand2 ,out vec3 incoming_dir, out float PDF)
{
    PDF = 0.0;

    float phi = 2.0 * PI * rand1;
    float r   = sqrt(rand2);
    float x   = r * cos(phi);
    float y   = r * sin(phi);
    float z   = sqrt(1.0 - rand2);

    vec3 local_direction = vec3(x, y, z);

    vec3 T1;
    vec3 T2;
    buildOrthonormalBasis(normal, T1, T2);

    incoming_dir = normalize(local_direction.x * T1 + local_direction.y * T2 + local_direction.z * normal);

    PDF = getDiffusePDF(normal, incoming_dir);
}

vec3 evaluateBRDF(const in vec3 normal, const in vec3 incoming_dir, const in vec3 outgoing_dir, const in vec3 baseColor, const in vec3 F0, const in float roughness)
{
    // we need the f value. its f of diffuse + f of specular.
    float Ndotw_i = dot(normal, incoming_dir);
    float Ndotw_o = dot(normal, outgoing_dir);
    if (Ndotw_i <= 1e-6|| Ndotw_o <= 1e-6)
        return vec3(0.0);

    //we calculate f of difuse simple lambertian term
    vec3 f_diffuse = baseColor * INV_PI;

    //we now calculate f of specular GGX
    vec3 H = normalize(incoming_dir + outgoing_dir);
    float NdotH = max(dot(normal, H), 0.0);
    float w_odotH = max(dot(outgoing_dir, H), 0.0);

    float alpha = roughness * roughness;

    float D   = GGX_D(NdotH, alpha);
    float G1v = GGX_G1(Ndotw_o, alpha);
    float G1l = GGX_G1(Ndotw_i, alpha);
    float G   = G1v * G1l;

    vec3 F = fresnel_Schlick(w_odotH, F0);

    vec3 f_specular = (D * G * F) / max(4.0 * Ndotw_i * Ndotw_o, 1e-6);

    //thats it
    return f_diffuse + f_specular;
}

void BRDF(const in vec3 normal, const in vec3 outgoing_dir,
          const in vec3 baseColor, const in vec3 F0, const in float roughness,
          const in float randLobe, const in float rand1, const in float rand2,
          out vec3 incoming_dir, out vec3 BRDF_value, out float BRDF_PDF)
{
    incoming_dir = vec3(0.0);
    BRDF_value = vec3(0.0);
    BRDF_PDF = 0.0;

    // make sure normal and outgoing direction are on the same side.
    float cosineTheta = dot(normal, outgoing_dir);
    if (cosineTheta <= 1e-6)
        return;

    // pick 2 weights such that they add to 1 to pick from diffuse or GGX
    vec3 Fview = fresnel_Schlick(cosineTheta, F0);
    float specular_weight = clamp(max(max(Fview.r, Fview.g), Fview.b), 0.0, 0.98);
    float diffuse_weight = 1.0 - specular_weight;

    vec3 candidate_wi = vec3(0.0);
    float s_pdf = 0.0;
    float d_pdf = 0.0;
    if (randLobe < specular_weight)
    {
        //if we are sampling specular (GGX):
        sampleGGX(normal, outgoing_dir, roughness, rand1, rand2 ,candidate_wi, s_pdf);
        d_pdf = getDiffusePDF(normal,candidate_wi);
    }
    else
    {
        //if we are sampling diffuse (Lambert):
        sampleDiffuse(normal,rand1, rand2, candidate_wi, d_pdf);
        s_pdf = getGGXPDF(normal, outgoing_dir, roughness, candidate_wi);
    }

    //now we can combine the PDF's with the weights used to pick sampling strategy.
    float pdf = specular_weight * s_pdf + diffuse_weight * d_pdf;

    //after some final gates we can assign the out values. for BRDF value we will call the evaluating function
    if (pdf <= 0.0)
        return;
    incoming_dir = candidate_wi;
    BRDF_value = evaluateBRDF(normal, candidate_wi, outgoing_dir, baseColor, F0, roughness);
    BRDF_PDF = pdf;
}

void BSDF(const in vec3 normal, const in vec3 outgoing_dir, inout uint rngState,
          const in vec3 baseColor, const in vec3 F0, const in float roughness, const in vec3 emission,
          out vec3 incoming_dir, out vec3 BSDF_value, out float BSDF_PDF)
{
    incoming_dir = vec3(0.0);
    BSDF_value = vec3(0.0);
    BSDF_PDF = 0.0;

    // generate some random values to be used
    float randLobe = rand(rngState);
    float rand1 = rand(rngState);
    float rand2 = rand(rngState);
    // in the future add BTDF branch
    vec3 w_i_BRDF;
    vec3 BRDF_value;
    float BRDF_PDF;

    // this will need the material data and random values
    BRDF(normal, outgoing_dir, baseColor, F0, roughness, randLobe, rand1, rand2, w_i_BRDF, BRDF_value, BRDF_PDF);
    
    if (BRDF_PDF <= 0.0)
        return;
    
    incoming_dir = w_i_BRDF;
    BSDF_value = BRDF_value;
    BSDF_PDF = BRDF_PDF;
}

uint sampleLightIndex(inout uint rngState, out float pdfLight)
{
    uint N = emissiveTrinagles[0].padding;
    if (N == 0u) {
        pdfLight = 0.0;
        return 0xFFFFFFFFu;
    }

    float u1 = rand(rngState);
    float u2 = rand(rngState);

    uint k = uint(u1 * float(N));
    if (k >= N) k = N - 1u;

    float q = lightProbability[k];
    uint  a = LightAlias[k];

    uint idx = (u2 < q) ? k : a;

    pdfLight = lightPDF[idx];
    return idx;
}

bool sampleSphericalTriangle( vec3 v0, vec3 v1, vec3 v2,
                              vec3 refP, vec2 u, 
                              out vec3 out_w, out float out_pdf)
{
    // Directions to vertices (unit)
    vec3 a = normalize(v0 - refP);
    vec3 b = normalize(v1 - refP);
    vec3 c = normalize(v2 - refP);

    if (length(a) == 0.0 || length(b) == 0.0 || length(c) == 0.0)
        return false;

    // Edge plane normals
    vec3 n_ab = cross(a, b);
    vec3 n_bc = cross(b, c);
    vec3 n_ca = cross(c, a);

    if (dot(n_ab, n_ab) == 0.0 ||
        dot(n_bc, n_bc) == 0.0 ||
        dot(n_ca, n_ca) == 0.0)
        return false;

    n_ab = normalize(n_ab);
    n_bc = normalize(n_bc);
    n_ca = normalize(n_ca);

    // Interior angles of spherical triangle
    float alpha = angleBetween(n_ab, -n_ca);
    float beta  = angleBetween(n_bc, -n_ab);
    float gamma = angleBetween(n_ca, -n_bc);

    // Spherical area A = (alpha+beta+gamma) - PI
    float A_pi  = alpha + beta + gamma;
    float A     = A_pi - PI;
    if (A <= 0.0) return false;

    // Uniform in solid angle => pdf = 1 / A
    out_pdf = 1.0 / A;

    // Sample partial area A' linearly between 0 and A
    float Ap = u.x * A;
    float Ap_pi = Ap + PI; // A' + PI

    // Now compute B' at vertex corresponding to 'a' (pbrt-style)
    float cosAlpha = cos(alpha);
    float sinAlpha = sin(alpha);

    float sinAp   = sin(Ap_pi);
    float cosAp   = cos(Ap_pi);

    float sinPhi = sinAp * cosAlpha - cosAp * sinAlpha;
    float cosPhi = cosAp * cosAlpha + sinAp * sinAlpha;

    float k1 = cosPhi + cosAlpha;
    float cos_c = dot(a, b); // side length opposite vertex c
    float k2 = sinPhi - sinAlpha * cos_c;

    float num   = k2 + differenceOfProducts(k2, cosPhi, k1, sinPhi) * cosAlpha;
    float denom = (sumOfProducts(k2, sinPhi, k1, cosPhi)) * sinAlpha;

    if (abs(denom) < 1e-8)
        return false;

    float cosBp = num / denom;
    cosBp = clamp(cosBp, -1.0, 1.0);
    float sinBp = safeSqrt(1.0 - cosBp * cosBp);

    // New third vertex C' along arc AC
    vec3 c_ortho = gramSchmidt(c, a);
    vec3 cp = cosBp * a + sinBp * normalize(c_ortho);

    // Sample direction along arc from b to c'
    float dot_bc = dot(b, cp);
    float cosTheta = 1.0 - u.y * (1.0 - dot_bc);
    cosTheta = clamp(cosTheta, -1.0, 1.0);
    float sinTheta = safeSqrt(1.0 - cosTheta * cosTheta);

    vec3 axis = gramSchmidt(cp, b);
    vec3 w = cosTheta * b + sinTheta * normalize(axis);

    out_w = normalize(w);
    return true;
}



vec3 lightSample( vec3 hitPoint, vec3 normal, vec3 outgoing_dir, inout uint rngState,
                  const vec3 baseColor, const vec3 F0, const float roughness)
{
    vec3 luminance = vec3(0.0);

    float pdfLight;
    uint numberOfLights = emissiveTrinagles[0].padding;
    if (numberOfLights == 0u)
        return luminance;

    float u1 = rand(rngState);
    float u2 = rand(rngState);

    uint k = uint(u1 * float(numberOfLights));
    if (k >= numberOfLights)
        k = numberOfLights - 1u;

    float q = lightProbability[k];
    uint  a = LightAlias[k];
    uint  lightIdx = (u2 < q) ? k : a;

    pdfLight = lightPDF[lightIdx];
    if (pdfLight <= 0.0)
        return luminance;


    uint materialIdx = emissiveTrinagles[lightIdx].materialIndex;
    uint primIdx = emissiveTrinagles[lightIdx].primitiveIndex;
    uint instIdx = emissiveTrinagles[lightIdx].instanceIndex;

    MollerTriangle  tri  = triangles[primIdx];

    // Model-space triangle vertices
    vec3 v0_model = vec3(tri.vertex_0);
    vec3 v1_model = v0_model + vec3(tri.edge_vec1);
    vec3 v2_model = v0_model + vec3(tri.edge_vec2);

    // World-space vertices
    vec3 v0_world = affineTransformPoint(v0_model,
                                         instances[instIdx].modelToWorld0,
                                         instances[instIdx].modelToWorld1,
                                         instances[instIdx].modelToWorld2);
    vec3 v1_world = affineTransformPoint(v1_model,
                                         instances[instIdx].modelToWorld0,
                                         instances[instIdx].modelToWorld1,
                                         instances[instIdx].modelToWorld2);
    vec3 v2_world = affineTransformPoint(v2_model,
                                         instances[instIdx].modelToWorld0,
                                         instances[instIdx].modelToWorld1,
                                         instances[instIdx].modelToWorld2);

    vec2 u = vec2(rand(rngState), rand(rngState));
    vec3 incoming_dir;
    float pdfSolidAngle;
    if (!sampleSphericalTriangle(v0_world, v1_world, v2_world, hitPoint, u, incoming_dir, pdfSolidAngle))
        return luminance;

    if (pdfSolidAngle <= 0.0)
        return luminance;

    float pdfDir = pdfLight * pdfSolidAngle;
    if (pdfDir <= 0.0)
        return luminance;

    Ray shadowRay;
    shadowRay.origin = hitPoint + 1e-4 * incoming_dir;
    shadowRay.direction = incoming_dir;

    Hit shadowHit = Hit(1e30, 1e30, 0xFFFFFFFFu, 0xFFFFFFFFu, vec2(0.0));
    trace(shadowRay, shadowHit);

    if (shadowHit.instanceIndex != instIdx || shadowHit.primitiveIndex != primIdx)
        return luminance;

    float cosTheta = max(dot(normal, incoming_dir), 0.0);
    if (cosTheta <= 0.0)
        return luminance;

    vec3 Le = materials[materialIdx].emission_flags.xyz;
    vec3 f  = evaluateBRDF(normal, incoming_dir, outgoing_dir, baseColor, F0, roughness);

    luminance += Le * f * (cosTheta / pdfDir);
    return luminance;
}



vec3 solveRenderingEquationForHit(inout Ray ray, inout Hit hit, inout vec3 throughput, inout uint rngState, const in uvec2 pixel)
{
    vec3 luminance = vec3(0.0);

    //shading trinagle for normal data
    ShadingTriangle trinagle = shadingTris[hit.primitiveIndex];
    vec4 vertex0_data = trinagle.vertexNormal0_uv;
    vec4 vertex1_data = trinagle.vertexNormal1_uv;
    vec4 vertex2_data = trinagle.vertexNormal2_uv;

    //get material for this hit.
    vec4 texture_material = trinagle.texture_materialId;
    uint materialIndex = floatBitsToUint(texture_material.w);
    materialIndex += instances[hit.instanceIndex].bases01.w;
    MaterialGPU material = materials[materialIndex];
    uint textureIndex = floatBitsToUint(material.textureId.x);

    
    //grab the intended base color
    vec3 baseColor = material.baseColor_opacity.xyz;
    if (textureIndex != 0xFFFFFFFFu)
    {
        
    
        vec2 vt0 = vec2(vertex0_data.w, texture_material.x);
        vec2 vt1 = vec2(vertex1_data.w, texture_material.y);
        vec2 vt2 = vec2(vertex2_data.w, texture_material.z);
        
        baseColor *= vec3(getTextureSample(textureIndex, hit, vt0, vt1, vt2, ray, pixel));
    }

    // interpolate the normal and convert it to world space;
    vec3 normal = interpNormal(vertex0_data.xyz, vertex1_data.xyz, vertex2_data.xyz, hit.barrycentricUV.x, hit.barrycentricUV.y);
    bool frontFace = dot(normal, -ray.direction) > 0.0;
    normal = frontFace ? normal : -normal;
    //this needs to be swaped for inverse transpose of linnear part of the model->world matrix that needs to be calculated per instance on the cpu
    normal = affineTransformDirection(normal, instances[hit.instanceIndex].modelToWorld0, instances[hit.instanceIndex].modelToWorld1, instances[hit.instanceIndex].modelToWorld2);

    //get luminacne for this hit.
    luminance += throughput * material.emission_flags.xyz;
    //get hit point in world space
    vec3 hitPoint = ray.origin + hit.world_dist_to_hit * ray.direction;

    vec3 Ldirect = lightSample(hitPoint,
                               normal,
                               -ray.direction,
                               rngState,
                               baseColor,
                               material.F0_ior_rough.xyz,
                               material.F0_ior_rough.w);

    luminance += throughput * Ldirect;



    //sample BSDF
    vec3 f_BSDF;
    float pdf_wi;
    BSDF(normal, -ray.direction, rngState, 
         baseColor, material.F0_ior_rough.xyz, material.F0_ior_rough.w, material.emission_flags.xyz,
         ray.direction, f_BSDF, pdf_wi);
        
    //finalise the new ray
    ray.origin = hitPoint + 1e-5 * ray.direction;

    //update the throughput
    float cosineTheta = dot(normal, ray.direction);
    if (pdf_wi > 0.0 && cosineTheta > 0.0)
        throughput *= f_BSDF * (cosineTheta / pdf_wi);

    return luminance;
}

vec3 samplePath(Ray ray, uvec2 pixel, inout uint rngState)
{
    vec3 luminacne = vec3(0.0);
    vec3 throughput = vec3(1.0);

    const int MAX_DEPTH = 200;
    const int MIN_DEPTH = 1;

    bool instanceSelected = (Params.flags & FLAG_INSTANCE_SEL) != 0u;
    uint selectedIdx      = Params.flags & MASK_INSTANCE_IDX;

    for (int bounce = 0; bounce < MAX_DEPTH; bounce++)
    {
        Hit hit = Hit(1e30, 1e30, 0xFFFFFFFFu, 0xFFFFFFFFu, vec2(0.0));
        trace(ray, hit);

        if (hit.instanceIndex == 0xFFFFFFFFu && hit.primitiveIndex == 0xFFFFFFFFu)
            break;

        if (hit.instanceIndex != 0xFFFFFFFFu && hit.primitiveIndex != 0xFFFFFFFFu)
        {
            luminacne += solveRenderingEquationForHit(ray, hit, throughput, rngState, pixel);
            if (instanceSelected && hit.instanceIndex == selectedIdx && bounce == 0)
                luminacne = mix(luminacne, vec3(1.0, 1.0, 0.0), 0.4);
        }

        if (bounce >= MIN_DEPTH)
        {
            float p = clamp(max(throughput.r, max(throughput.g, throughput.b)), 0.0, 0.99);
            float xi = rand(rngState);
            if (xi > p)
                break;
            throughput /= p;
        }
    }

    return luminacne;
}


// ~~~~~~~~~~~~~ main ~~~~~~~~~~~~~

void main()
{
    //early pixel gate && get pixel XY.
    uvec2 pixel = gl_GlobalInvocationID.xy;
    if (pixel.x >= Params.imageSize.x || pixel.y >= Params.imageSize.y)
        return;

    
    bool bPressedFlag     = (Params.flags & FLAG_B) != 0u;
    
    uint  bInterpRaw      = (Params.flags & B_INTERP_MASK) >> B_INTERP_SHIFT;
    bool  bTransitionPlaying = (bInterpRaw != 0u);
    float bInterp         = float(bInterpRaw) / float(0x3FFu);
    uint pixelIndex = pixel.x + pixel.y * Params.imageSize.x;
    uint rngState = wang_hash(uint(pixelIndex ^ (floatBitsToUint(Params.camPos_time.w) * 1664525u)));
    
    

    vec3 color = vec3(0.0);
    for (int SPP = 0; SPP < 1; SPP++)
    {
        vec2 jitter = vec2(rand(rngState), rand(rngState));
        Ray ray = generateRayJittered(pixel, jitter);
        color += samplePath(ray, pixel, rngState);
    }
    color /= 1.0;

       
    imageStore(outImage, ivec2(pixel), vec4(color, 1.0));
}







